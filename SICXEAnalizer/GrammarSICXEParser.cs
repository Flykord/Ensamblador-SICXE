//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 4.6.6
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// Generated from C:\Users\alfre\source\repos\Prueba300\GrammarSICXE.g4 by ANTLR 4.6.6

// Unreachable code detected
#pragma warning disable 0162
// The variable '...' is assigned but its value is never used
#pragma warning disable 0219
// Missing XML comment for publicly visible type or member '...'
#pragma warning disable 1591
// Ambiguous reference in cref attribute
#pragma warning disable 419

namespace Example.Generated {
using Antlr4.Runtime;
using Antlr4.Runtime.Atn;
using Antlr4.Runtime.Misc;
using Antlr4.Runtime.Tree;
    using SICXEAnalizer;
    using System;
    using System.Collections.Generic;
   
using DFA = Antlr4.Runtime.Dfa.DFA;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.6.6")]
[System.CLSCompliant(false)]
public partial class GrammarSICXEParser : Parser {
        public List<CSECT> cs = new List<CSECT>();
        public string num = "";
        public int numeroSecuencia = 0;
        public int paso = 0;
        public int defex = 0;
        public int refex = 0;
        public int esWord = 0;
        public int expresionlarga = 0;
        public string etiquetaEQU = "";
        public int verificaExpresion = 0;
        public int directivaEQU = 0;
        public string resultadoexpresion = "";
        public int valorEtiqueta = 0;
        public List<string> pb1 = new List<string>();
        public List<string> errores = new List<string>();
        public int simbolduplicated = 0;
        public List<string> tabsimb = new List<string>();
        public List<int> dirTabsim = new List<int>();
        public List<string> nombreBloques = new List<string>();
        public List<string> numBloque = new List<string>();
        public int numeroBloque = 0;
        public List<string> dirTabimHex = new List<string>();
        public List<string> Tipotabsim = new List<string>();
        public List<string> format = new List<string>();
        public List<string> errorType = new List<string>();
        public List<int> contProg = new List<int>();
        public List<string> p1 = new List<string>();
        public List<string> probando = new List<string>();
        public List<string> mododir = new List<string>();
        public List<string> Errorespaso2 = new List<string>();
        public int noEsEtiqueta = 0;
        bool enter = false;
        public string BASE = "0";
        int solounavez = 0;
        string[] nemonicos = { "ADD", "ADDF", "ADDR", "AND", "CLEAR", "COMP", "COMPF", "COMPR", "DIV", "DIVF", "DIVR", "FIX", "FLOAT", "HIO", "J", "JEQ", "JGT", "JLT", "JSUB", "LDA", "LDB", "LDCH", "LDF", "LDL", "LDS", "LDT", "LDX", "LPS", "MUL", "MULF", "MULR", "NORM", "OR", "RD", "RMO", "RSUB", "SHIFTL", "SHIFTR", "SIO", "SSK", "STA", "STB", "STCH", "STF", "STI", "STL", "STS", "STSW", "STT", "STX", "SUB", "SUBF", "SUBR", "SVC", "TD", "TIO", "TIX", "TIXR", "WD" };
        string[] CodOp = { "18", "58", "90", "40", "B4", "28", "88", "A0", "24", "64", "9C", "C4", "C0", "F4", "3C", "30", "34", "38", "48", "00", "68", "50", "70", "08", "6C", "74", "04", "D0", "20", "60", "98", "C8", "44", "D8", "AC", "4C", "A4", "A8", "F0", "EC", "0C", "78", "54", "80", "D4", "14", "7C", "E8", "84", "10", "1C", "5C", "94", "B0", "E0", "F8", "2C", "B8", "DC" };
        //string[] registros = { "A","X","L","B", "S" , "T" , "F" } ;
        public int A = 0;
        public int X = 1;
        public int L = 2;
        public int B = 3;
        public int S = 4;
        public int T = 5;
        public int F = 6;
        public int mr = 0;
        public int[] contador = new int[5];
        public string cphex;
        public List<string> conthex = new List<string>();
        public List<string> codobj = new List<string>();
        public int cp = 0;
        public int b = 0;
        public int format4 = 0;
        public int form4 = 0;
        List<int> lineas = new List<int>();
        public int tipo = 0;
        public const int
		T__0=1, T__1=2, T__2=3, T__3=4, T__4=5, T__5=6, T__6=7, T__7=8, T__8=9, 
		T__9=10, T__10=11, T__11=12, T__12=13, T__13=14, T__14=15, T__15=16, T__16=17, 
		T__17=18, T__18=19, T__19=20, T__20=21, T__21=22, T__22=23, T__23=24, 
		T__24=25, T__25=26, T__26=27, T__27=28, T__28=29, T__29=30, T__30=31, 
		T__31=32, T__32=33, T__33=34, T__34=35, T__35=36, T__36=37, T__37=38, 
		T__38=39, T__39=40, T__40=41, T__41=42, T__42=43, T__43=44, T__44=45, 
		T__45=46, T__46=47, T__47=48, T__48=49, T__49=50, T__50=51, T__51=52, 
		T__52=53, T__53=54, T__54=55, T__55=56, T__56=57, T__57=58, T__58=59, 
		T__59=60, T__60=61, T__61=62, T__62=63, T__63=64, T__64=65, T__65=66, 
		T__66=67, T__67=68, T__68=69, T__69=70, T__70=71, T__71=72, T__72=73, 
		T__73=74, T__74=75, T__75=76, T__76=77, T__77=78, T__78=79, T__79=80, 
		T__80=81, NUM=82, CONSTHEX=83, CONSTCAD=84, ID=85, FINL=86, PARENI=87, 
		PAREND=88, MAS=89, MENOS=90, POR=91, INT=92, ENTRE=93, WS=94;
	public const int
		RULE_programa = 0, RULE_inicio = 1, RULE_etiqueta = 2, RULE_fin = 3, RULE_entrada = 4, 
		RULE_proposiciones = 5, RULE_proposiciones1 = 6, RULE_proposicion = 7, 
		RULE_instruccion = 8, RULE_directiva = 9, RULE_direxref = 10, RULE_direxdef = 11, 
		RULE_tipodirectiva = 12, RULE_base = 13, RULE_opdirectiva = 14, RULE_opinstruccion = 15, 
		RULE_formato = 16, RULE_f1 = 17, RULE_f2 = 18, RULE_f3 = 19, RULE_f4 = 20, 
		RULE_simple3 = 21, RULE_indirecto3 = 22, RULE_inmediato3 = 23, RULE_subf2a = 24, 
		RULE_subf2b = 25, RULE_subf2c = 26, RULE_subf2d = 27, RULE_codop1 = 28, 
		RULE_codop2 = 29, RULE_codop3 = 30, RULE_reg = 31, RULE_expresion = 32, 
		RULE_multiplicacion = 33, RULE_numero = 34;
	public static readonly string[] ruleNames = {
		"programa", "inicio", "etiqueta", "fin", "entrada", "proposiciones", "proposiciones1", 
		"proposicion", "instruccion", "directiva", "direxref", "direxdef", "tipodirectiva", 
		"base", "opdirectiva", "opinstruccion", "formato", "f1", "f2", "f3", "f4", 
		"simple3", "indirecto3", "inmediato3", "subf2a", "subf2b", "subf2c", "subf2d", 
		"codop1", "codop2", "codop3", "reg", "expresion", "multiplicacion", "numero"
	};

	private static readonly string[] _LiteralNames = {
		null, "'START'", "'END'", "'BYTE'", "'EQU'", "'EQU*'", "'USE'", "'CSECT'", 
		"'EXTREF'", "','", "'EXTDEF'", "'WORD'", "'RESB'", "'RESW'", "'BASE'", 
		"'X'", "'@'", "'#'", "'SHIFTL'", "'SHIFTR'", "'CLEAR'", "'TIXR'", "'SVC'", 
		"'FIX'", "'FLOAT'", "'HIO'", "'NORM'", "'SIO'", "'TIO'", "'ADDR'", "'SUBR'", 
		"'COMPR'", "'DIVR'", "'MULR'", "'RMO'", "'ADD'", "'ADDF'", "'AND'", "'COMP'", 
		"'COMPF'", "'DIV'", "'DIVF'", "'J'", "'JEQ'", "'JGT'", "'JLT'", "'JSUB'", 
		"'LDA'", "'LDB'", "'LDCH'", "'LDF'", "'LDL'", "'LDS'", "'LDX'", "'LPS'", 
		"'MUL'", "'MULF'", "'OR'", "'RD'", "'RSUB'", "'SSK'", "'STA'", "'STB'", 
		"'STCH'", "'STF'", "'STI'", "'STL'", "'STS'", "'STSW'", "'STT'", "'STX'", 
		"'SUB'", "'SUBF'", "'TD'", "'TIX'", "'WD'", "'A'", "'L'", "'B'", "'S'", 
		"'T'", "'F'", null, null, null, null, null, "'('", "')'", "'+'", "'-'", 
		"'*'", null, "'/'"
	};
	private static readonly string[] _SymbolicNames = {
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, "NUM", "CONSTHEX", 
		"CONSTCAD", "ID", "FINL", "PARENI", "PAREND", "MAS", "MENOS", "POR", "INT", 
		"ENTRE", "WS"
	};
	public static readonly IVocabulary DefaultVocabulary = new Vocabulary(_LiteralNames, _SymbolicNames);

	[System.Obsolete("Use Vocabulary instead.")]
	public static readonly string[] tokenNames = GenerateTokenNames(DefaultVocabulary, _SymbolicNames.Length);

	private static string[] GenerateTokenNames(IVocabulary vocabulary, int length) {
		string[] tokenNames = new string[length];
		for (int i = 0; i < tokenNames.Length; i++) {
			tokenNames[i] = vocabulary.GetLiteralName(i);
			if (tokenNames[i] == null) {
				tokenNames[i] = vocabulary.GetSymbolicName(i);
			}

			if (tokenNames[i] == null) {
				tokenNames[i] = "<INVALID>";
			}
		}

		return tokenNames;
	}

	[System.Obsolete("Use IRecognizer.Vocabulary instead.")]
	public override string[] TokenNames
	{
		get
		{
			return tokenNames;
		}
	}

	[NotNull]
	public override IVocabulary Vocabulary
	{
		get
		{
			return DefaultVocabulary;
		}
	}

	public override string GrammarFileName { get { return "GrammarSICXE.g4"; } }

	public override string[] RuleNames { get { return ruleNames; } }

	public override string SerializedAtn { get { return _serializedATN; } }

	public GrammarSICXEParser(ITokenStream input)
		: base(input)
	{
		_interp = new ParserATNSimulator(this,_ATN);
	}
	public partial class ProgramaContext : ParserRuleContext {
		public InicioContext inicio() {
			return GetRuleContext<InicioContext>(0);
		}
		public ProposicionesContext proposiciones() {
			return GetRuleContext<ProposicionesContext>(0);
		}
		public FinContext fin() {
			return GetRuleContext<FinContext>(0);
		}
		public ITerminalNode Eof() { return GetToken(GrammarSICXEParser.Eof, 0); }
		public ProgramaContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_programa; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGrammarSICXEVisitor<TResult> typedVisitor = visitor as IGrammarSICXEVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPrograma(this);
			else return visitor.VisitChildren(this);
		}
	}

        public void erroresProg(RecognitionException re)
        {
            if (paso == 1)
            {
                if (cs[numeroSecuencia].errores.Count > 0)
                {
                    int c = 0;
                    foreach (int a in cs[numeroSecuencia].lineas)
                    {
                        if (a == re.OffendingToken.Line)
                        {
                            c = 1;
                        }
                    }
                    if (c == 0)
                    {
                        cs[numeroSecuencia].errores.Add("Error en linea :" + re.OffendingToken.Line + " , " + re.OffendingToken.Text);
                        cs[numeroSecuencia].lineas.Add(re.OffendingToken.Line);
                        cs[numeroSecuencia].contProg.Add(cp);
                        //conthex.Add(cp.ToString("X"));
                        cs[numeroSecuencia].format.Add("Error"+re.OffendingToken.Text);
                        cs[numeroSecuencia].mododir.Add("----");
                    }

                }
                else
                {
                    cs[numeroSecuencia].errores.Add("Error en linea :" + re.OffendingToken.Line + " , " + re.OffendingToken.Text);
                    cs[numeroSecuencia].contProg.Add(cp);
                    cs[numeroSecuencia].conthex.Add(cp.ToString("X"));
                    cs[numeroSecuencia].lineas.Add(re.OffendingToken.Line);
                    cs[numeroSecuencia].format.Add("Error");
                    cs[numeroSecuencia].mododir.Add("----");
                }
            }
            if (paso == 2)
            {

                if (b == 0)
                {
                    cs[numeroSecuencia].probando.Add("----");
                    b = re.OffendingToken.Line;
                }
                else
                {
                    if (b == re.OffendingToken.Line)
                    {
                        b = 0;
                    }
                }

            }
        }

        [RuleVersion(0)]
	public ProgramaContext programa() {
            CSECT poromision = new CSECT();
		ProgramaContext _localctx = new ProgramaContext(_ctx, State);
		EnterRule(_localctx, 0, RULE_programa);
		try {
                cs.Add(poromision);
			EnterOuterAlt(_localctx, 1);
			{
			State = 70; inicio();
			State = 71; proposiciones();
			State = 72; fin();
			State = 73; Match(Eof);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
                erroresProg(re);

        }
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class InicioContext : ParserRuleContext {
		public EtiquetaContext etiqueta() {
			return GetRuleContext<EtiquetaContext>(0);
		}
		public ITerminalNode NUM() { return GetToken(GrammarSICXEParser.NUM, 0); }
		public ITerminalNode FINL() { return GetToken(GrammarSICXEParser.FINL, 0); }
		public ProposicionContext proposicion() {
			return GetRuleContext<ProposicionContext>(0);
		}
		public InicioContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_inicio; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGrammarSICXEVisitor<TResult> typedVisitor = visitor as IGrammarSICXEVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitInicio(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public InicioContext inicio() {
		InicioContext _localctx = new InicioContext(_ctx, State);
		EnterRule(_localctx, 2, RULE_inicio);
		try {
                if (paso == 1)
                {
                    cs[numeroSecuencia].format.Add("----");
                    cs[numeroSecuencia].mododir.Add("----");
                    cs[numeroSecuencia].contProg.Add(cp);
                    cs[numeroSecuencia].cp += 0;
                    cs[numeroSecuencia].conthex.Add(cp.ToString("X"));
                    cs[numeroSecuencia].nombreSeccion = _input.Lt(1).Text;
                    format.Add("----");
                    mododir.Add("----");
                    contProg.Add(cp);
                    // conthex.Add(cp.ToString("X"));
                    cp += 0;
                    numBloque.Add(numeroBloque.ToString());
                    nombreBloques.Add(_input.Lt(1).Text);
                }
                if (paso == 2)
                {
                    cs[numeroSecuencia].probando.Add("----");
                    probando.Add("----");

                }
                State = 83;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,0,_ctx) ) {
			case 1:
                        cs[numeroSecuencia].noEsEtiqueta = 1;

                EnterOuterAlt(_localctx, 1);
				{
				State = 75; etiqueta();
				State = 76; Match(T__0);
				State = 77; Match(NUM);
				State = 78; Match(FINL);
				}
                        cs[numeroSecuencia].noEsEtiqueta = 0;

                break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 80; proposicion();
				State = 81; Match(FINL);
				}
				break;
			}
		}
		catch (RecognitionException re) {
                
                cs[numeroSecuencia].mr = 1;
                _localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
                erroresProg(re);
            }
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class EtiquetaContext : ParserRuleContext {
		public ITerminalNode ID() { return GetToken(GrammarSICXEParser.ID, 0); }
		public EtiquetaContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_etiqueta; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGrammarSICXEVisitor<TResult> typedVisitor = visitor as IGrammarSICXEVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitEtiqueta(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public EtiquetaContext etiqueta() {
            
            cs[numeroSecuencia].etiquetaEQU = _input.Lt(1).Text;
            EtiquetaContext _localctx = new EtiquetaContext(_ctx, State);
		EnterRule(_localctx, 4, RULE_etiqueta);
		try {
               
                cs[numeroSecuencia].simbolduplicated = 0;
                State = 87;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,1,_ctx) ) {
			case 1:
                        //Agregar etiqueta a TABSIM _input.Lt(1).Text es el dato considerado etiqueta
                        if (paso == 1)
                        {
                            if (cs[numeroSecuencia].tabsimb.Count > 0)
                            {
                                if (cs[numeroSecuencia].directivaEQU == 0 && defex==0)
                                {
                                    bool rep = cs[numeroSecuencia].tabsimb.Contains(_input.Lt(1).Text);
                                    if (rep)
                                    {
                                        cs[numeroSecuencia]. errores.Add("Error simbolo" + "  " + _input.Lt(1).Text + " duplicado");
                                        cs[numeroSecuencia].simbolduplicated = 1;
                                    }
                                    else
                                    {
                                        if (cs[numeroSecuencia].noEsEtiqueta == 0 && defex==0 && refex==0)
                                        {
                                            cs[numeroSecuencia].tabsimb.Add(_input.Lt(1).Text);
                                            cs[numeroSecuencia].dirTabsim.Add(cp);
                                            cs[numeroSecuencia].dirTabimHex.Add(cp.ToString("X"));
                                            cs[numeroSecuencia].referenciaExterna.Add("No");

                                        }
                                        if (cs[numeroSecuencia].noEsEtiqueta == 0 && defex == 0 && refex == 1)
                                        {
                                            cs[numeroSecuencia].tabsimb.Add(_input.Lt(1).Text);
                                            cs[numeroSecuencia].dirTabsim.Add(0);
                                            cs[numeroSecuencia].Tipotabsim.Add("----");
                                            cs[numeroSecuencia].dirTabimHex.Add("0");
                                            cs[numeroSecuencia].referenciaExterna.Add("Si");

                                        }
                                        //conthex.Add(cp.ToString("X"));
                                        cs[numeroSecuencia].contProg.Add(cp);
                                        if (tipo == 1)
                                        {
                                            // Tipotabsim.Add("R");
                                        }
                                        else
                                        {
                                            if (tipo == 0)
                                            {
                                                //   Tipotabsim.Add("As");
                                            }
                                        }



                                    }
                                }
                                else
                                {
                                    if (directivaEQU == 1)
                                    {
                                        if (noEsEtiqueta == 0 &&defex==0)
                                        {
                                            cs[numeroSecuencia].tabsimb.Add(_input.Lt(1).Text);
                                            cs[numeroSecuencia].dirTabsim.Add(valorEtiqueta);
                                            cs[numeroSecuencia].dirTabimHex.Add(valorEtiqueta.ToString("X"));
                                            //conthex.Add(cp.ToString("X"));
                                            //contProg.Add(v);
                                        }
                                    }
                                }
                            }
                            else
                            {
                                if (cs[numeroSecuencia].noEsEtiqueta == 0 && defex==0 &&refex==0)
                                {
                                    cs[numeroSecuencia].tabsimb.Add(_input.Lt(1).Text);
                                    cs[numeroSecuencia].dirTabsim.Add(cp);
                                    cs[numeroSecuencia].dirTabimHex.Add(cp.ToString("X"));
                                    cs[numeroSecuencia].referenciaExterna.Add("No");
                                }
                                else
                                {
                                    if (cs[numeroSecuencia].noEsEtiqueta == 0 && defex == 0 && refex == 1)
                                    {
                                        cs[numeroSecuencia].tabsimb.Add(_input.Lt(1).Text);
                                        cs[numeroSecuencia].dirTabsim.Add(cp);
                                        cs[numeroSecuencia].dirTabimHex.Add(cp.ToString("X"));
                                        cs[numeroSecuencia].referenciaExterna.Add("Si");
                                    }
                                }
                                cs[numeroSecuencia].contProg.Add(cp);
                                //cs[numeroSecuencia].conthex.Add(cp.ToString("X"));
                                if (tipo == 1)
                                {
                                    // Tipotabsim.Add("R");
                                }
                                else
                                {
                                    if (tipo == 0)
                                    {
                                        //  Tipotabsim.Add("An");
                                    }
                                }
                            }
                        }
                        EnterOuterAlt(_localctx, 1);
				{
				State = 85; Match(ID);
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				}
				break;
			}
                cs[numeroSecuencia].noEsEtiqueta = 0;
            }
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
                erroresProg(re);
            }
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FinContext : ParserRuleContext {
		public EntradaContext entrada() {
			return GetRuleContext<EntradaContext>(0);
		}
		public ITerminalNode FINL() { return GetToken(GrammarSICXEParser.FINL, 0); }
		public FinContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_fin; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGrammarSICXEVisitor<TResult> typedVisitor = visitor as IGrammarSICXEVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFin(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public FinContext fin() {
		FinContext _localctx = new FinContext(_ctx, State);
		EnterRule(_localctx, 6, RULE_fin);
		try {
                if (paso == 1)
                {
                    cs[numeroSecuencia].mododir.Add("----");
                    cs[numeroSecuencia].format.Add("----");
                    cs[numeroSecuencia].conthex.Add((cs[0].contProg[cs[0].contProg.Count-1]+3).ToString("X"));
                    cs[numeroSecuencia].contProg.Add(cs[0].contProg[cs[0].contProg.Count - 1]);
                }
                if (paso == 2)
                {
                    cs[numeroSecuencia].probando.Add("----");
                }
                State = 95;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,2,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 89; Match(T__1);
				State = 90; entrada();
				State = 91; Match(FINL);
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 93; Match(T__1);
				State = 94; entrada();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
                erroresProg(re);
            }
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class EntradaContext : ParserRuleContext {
		public ITerminalNode ID() { return GetToken(GrammarSICXEParser.ID, 0); }
		public EntradaContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_entrada; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGrammarSICXEVisitor<TResult> typedVisitor = visitor as IGrammarSICXEVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitEntrada(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public EntradaContext entrada() {
		EntradaContext _localctx = new EntradaContext(_ctx, State);
		EnterRule(_localctx, 8, RULE_entrada);
		try {
			State = 99;
			_errHandler.Sync(this);
			switch (_input.La(1)) {
			case ID:
				EnterOuterAlt(_localctx, 1);
				{
				State = 97; Match(ID);
				}
				break;
			case Eof:
			case FINL:
				EnterOuterAlt(_localctx, 2);
				{
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
                erroresProg(re);
            }
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ProposicionesContext : ParserRuleContext {
		public ProposicionContext proposicion() {
			return GetRuleContext<ProposicionContext>(0);
		}
		public Proposiciones1Context proposiciones1() {
			return GetRuleContext<Proposiciones1Context>(0);
		}
		public ProposicionesContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_proposiciones; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGrammarSICXEVisitor<TResult> typedVisitor = visitor as IGrammarSICXEVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitProposiciones(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ProposicionesContext proposiciones() {
		ProposicionesContext _localctx = new ProposicionesContext(_ctx, State);
		EnterRule(_localctx, 10, RULE_proposiciones);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 101; proposicion();
			State = 102; proposiciones1();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
                erroresProg(re);
            }
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Proposiciones1Context : ParserRuleContext {
		public ProposicionContext proposicion() {
			return GetRuleContext<ProposicionContext>(0);
		}
		public Proposiciones1Context proposiciones1() {
			return GetRuleContext<Proposiciones1Context>(0);
		}
		public Proposiciones1Context(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_proposiciones1; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGrammarSICXEVisitor<TResult> typedVisitor = visitor as IGrammarSICXEVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitProposiciones1(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Proposiciones1Context proposiciones1() {
		Proposiciones1Context _localctx = new Proposiciones1Context(_ctx, State);
		EnterRule(_localctx, 12, RULE_proposiciones1);
		try {
			State = 108;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,4,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 104; proposicion();
				State = 105; proposiciones1();
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
                erroresProg(re);
            }
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ProposicionContext : ParserRuleContext {
		public InstruccionContext instruccion() {
			return GetRuleContext<InstruccionContext>(0);
		}
		public DirectivaContext directiva() {
			return GetRuleContext<DirectivaContext>(0);
		}
		public ProposicionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_proposicion; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGrammarSICXEVisitor<TResult> typedVisitor = visitor as IGrammarSICXEVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitProposicion(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ProposicionContext proposicion() {
		ProposicionContext _localctx = new ProposicionContext(_ctx, State);
		EnterRule(_localctx, 14, RULE_proposicion);
		try {
			State = 112;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,5,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 110; instruccion();
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 111; directiva();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
                erroresProg(re);
            }
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class InstruccionContext : ParserRuleContext {
		public EtiquetaContext etiqueta() {
			return GetRuleContext<EtiquetaContext>(0);
		}
		public OpinstruccionContext opinstruccion() {
			return GetRuleContext<OpinstruccionContext>(0);
		}
		public ITerminalNode FINL() { return GetToken(GrammarSICXEParser.FINL, 0); }
		public InstruccionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_instruccion; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGrammarSICXEVisitor<TResult> typedVisitor = visitor as IGrammarSICXEVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitInstruccion(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public InstruccionContext instruccion() {
            int m = 0;
            InstruccionContext _localctx = new InstruccionContext(_ctx, State);
		EnterRule(_localctx, 16, RULE_instruccion);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 114; etiqueta();
			State = 115; opinstruccion();
			State = 116; Match(FINL);
			}
                for (int i = 0; i < nemonicos.Length; i++)
                {
                    if (nemonicos[i] == _input.Lt(1).Text)
                    {
                        m = i;
                        for (int j = 0; j <cs[numeroSecuencia].tabsimb.Count; j++)
                        {
                            if (_input.Lt(2).Text == cs[numeroSecuencia].tabsimb[j])
                            {
                                //probando.Add(_input.Lt(1).Text + CodOp[m] + "\t " + _input.Lt(2).Text + " "  );
                            }
                        }

                    }

                }
            }
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
                erroresProg(re);
            }
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DirectivaContext : ParserRuleContext {
		public EtiquetaContext etiqueta() {
			return GetRuleContext<EtiquetaContext>(0);
		}
		public TipodirectivaContext tipodirectiva() {
			return GetRuleContext<TipodirectivaContext>(0);
		}
		public ITerminalNode NUM() { return GetToken(GrammarSICXEParser.NUM, 0); }
		public ITerminalNode FINL() { return GetToken(GrammarSICXEParser.FINL, 0); }
		public BaseContext @base() {
			return GetRuleContext<BaseContext>(0);
		}
		public OpdirectivaContext opdirectiva() {
			return GetRuleContext<OpdirectivaContext>(0);
		}
		public ExpresionContext expresion() {
			return GetRuleContext<ExpresionContext>(0);
		}
		public ITerminalNode ID() { return GetToken(GrammarSICXEParser.ID, 0); }
		public DirexrefContext direxref() {
			return GetRuleContext<DirexrefContext>(0);
		}
		public DirexdefContext direxdef() {
			return GetRuleContext<DirexdefContext>(0);
		}
		public DirectivaContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_directiva; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGrammarSICXEVisitor<TResult> typedVisitor = visitor as IGrammarSICXEVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDirectiva(this);
			else return visitor.VisitChildren(this);
		}
	}

        private int buscaTipo(string etiq)
        {
            int i = 0;
            int n = 0;
            int tp = -1;
            string tipo = "";
            foreach (string s in cs[numeroSecuencia].tabsimb)
            {
                if (s.Equals(etiq))
                {

                    tipo = cs[numeroSecuencia].Tipotabsim[i];
                    break;
                }
                i++;
            }

            if (tipo == "R")
            {
                tp = 1;
            }
            else
            {
                if (tipo == "A")
                {
                    tp = 0;
                }


            }
            return tp;
        }

        private int buscaRef(string etiq)
        {
            int i = 0;
            int n = 0;
            int tp = -1;
            string tipo = "";
            foreach (string s in cs[numeroSecuencia].tabsimb)
            {
                if (s.Equals(etiq))
                {

                    tipo = cs[numeroSecuencia].referenciaExterna[i];
                    break;
                }
                i++;
            }

            if (tipo == "Si")
            {
                tp = -1;
            }
            else
            {
                if (tipo == "No")
                {
                    tp = 0;
                }


            }
            return tp;
        }

        [RuleVersion(0)]
	public DirectivaContext directiva() {
		DirectivaContext _localctx = new DirectivaContext(_ctx, State);
		EnterRule(_localctx, 18, RULE_directiva);
		try {
			State = 158;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,6,_ctx) ) {
			case 1:
                        cs[numeroSecuencia].Tipotabsim.Add("R");
                        directivaEQU = 0;
                        EnterOuterAlt(_localctx, 1);
				{
				State = 118; etiqueta();
				State = 119; tipodirectiva();
				State = 120; Match(NUM);
				State = 121; Match(FINL);
				}
				break;

			case 2:
                        cs[numeroSecuencia].Tipotabsim.Add("R");
                        directivaEQU = 0;
                        EnterOuterAlt(_localctx, 2);
				{
				State = 123; etiqueta();
				State = 124; @base();
				State = 125; Match(FINL);
				}
				break;

			case 3:
                        cs[numeroSecuencia].Tipotabsim.Add("R");
                        directivaEQU = 0;
                        EnterOuterAlt(_localctx, 3);
				{
				State = 127; etiqueta();
				State = 128; Match(T__2);
				State = 129; opdirectiva();
				State = 130; Match(FINL);
				}
				break;

			case 4:
                        if (paso == 1)
                        {

                            cp += 0;
                            cs[numeroSecuencia].conthex.Add(cp.ToString("X"));
                            cs[numeroSecuencia].format.Add("----");
                            cs[numeroSecuencia].mododir.Add("----");
                            cs[numeroSecuencia].dirTabsim.Add(cp);
                            cs[numeroSecuencia].dirTabimHex.Add(cp.ToString("X"));
                            //conthex.Add(cp.ToString("X"));
                            cs[numeroSecuencia].contProg.Add(cp);
                        }
                        EnterOuterAlt(_localctx, 4);
				{
				State = 132; etiqueta();
				State = 133; Match(T__3);
				State = 134; expresion();
				}
                        if (verificaExpresion == 1)
                        {
                            cs[numeroSecuencia].Tipotabsim.Add("R");
                            int nl1 = 0;
                            int ubicacionEtiqueta1 = 0;
                            foreach (string s in cs[numeroSecuencia].tabsimb)
                            {
                                if (s.Equals(cs[numeroSecuencia].etiquetaEQU))
                                {
                                    ubicacionEtiqueta1 = nl1;
                                }
                                nl1++;
                            }
                            cs[numeroSecuencia].dirTabimHex[ubicacionEtiqueta1] = cs[numeroSecuencia].valorEtiqueta.ToString("X");
                            valorEtiqueta = 0;
                        }
                        else if (verificaExpresion == 0)
                        {
                            cs[numeroSecuencia].Tipotabsim.Add("R");
                            int nl2 = 0;
                            int ubicacionEtiqueta2 = 0;
                            foreach (string s in cs[numeroSecuencia].tabsimb)
                            {
                                if (s.Equals(cs[numeroSecuencia].etiquetaEQU))
                                {
                                    ubicacionEtiqueta2 = nl2;
                                }
                                nl2++;
                            }
                            cs[numeroSecuencia].dirTabimHex[ubicacionEtiqueta2] = valorEtiqueta.ToString("X");
                            cs[numeroSecuencia].valorEtiqueta = 0;
                        }
                        if (verificaExpresion >= 2)
                        {
                            int nl3 = 0;
                            int ubicacionEtiqueta3 = 0;
                            foreach (string s in cs[numeroSecuencia].tabsimb)
                            {
                                if (s.Equals(cs[numeroSecuencia].etiquetaEQU))
                                {
                                    ubicacionEtiqueta3 = nl3;
                                }
                                nl3++;
                            }
                            cs[numeroSecuencia].dirTabimHex[ubicacionEtiqueta3] = "FFFF";
                            cs[numeroSecuencia].Tipotabsim[ubicacionEtiqueta3] = "A";
                            cs[numeroSecuencia].valorEtiqueta = 0;
                            valorEtiqueta = 0;
                        }
                        directivaEQU = 1;
                        cs[numeroSecuencia].directivaEQU = 1;
                        if (paso == 2)
                        {
                            cs[numeroSecuencia].probando.Add("----");
                        }

                        pb1.Add("EQU Expresion");
                        //int validaExpreson(pb1);
                        break;

			case 5:
                        cs[numeroSecuencia].Tipotabsim.Add("R");
                        directivaEQU = 1;
                        if (paso == 1)
                        {
                            cs[numeroSecuencia].cp += 0;
                            cp += 0;
                            cs[numeroSecuencia].conthex.Add(cp.ToString("X"));
                            cs[numeroSecuencia].format.Add("----");
                            cs[numeroSecuencia].mododir.Add("----");
                            /* dirTabsim.Add(cp);
                             dirTabimHex.Add(cp.ToString("X"));*/
                            //conthex.Add(cp.ToString("X"));
                            cs[numeroSecuencia].contProg.Add(cp);
                        }
                        pb1.Add("EQU*");
                        if (paso == 2)
                        {
                            cs[numeroSecuencia].probando.Add("----");
                        }
                        EnterOuterAlt(_localctx, 5);
				{
				State = 136; etiqueta();
				State = 137; Match(T__4);
				State = 138; Match(FINL);
				}
				break;

			case 6:
                        num = _input.Lt(3).Text;
                        //num = _input.Lt(3).Text;
                        EnterOuterAlt(_localctx, 6);
				{
				State = 140; etiqueta();
				State = 141; Match(T__3);
				State = 142; Match(NUM);
				State = 143; Match(FINL);
				}
                        if (paso == 1)
                        {
                            cp += 0;
                            cs[numeroSecuencia].cp += 0;
                            cs[numeroSecuencia].conthex.Add(cp.ToString("X"));
                            cs[numeroSecuencia].format.Add("----");
                            cs[numeroSecuencia].mododir.Add("----");
                            cs[numeroSecuencia].dirTabsim.Add(cp);
                            cs[numeroSecuencia].dirTabimHex.Add(cp.ToString("X"));
                            //conthex.Add(cp.ToString("X"));
                            cs[numeroSecuencia].contProg.Add(cp);
                        }
                        cs[numeroSecuencia].Tipotabsim.Add("A");
                        int nl = 0;
                        int ubicacionEtiqueta = 0;
                        foreach (string s in cs[numeroSecuencia].tabsimb)
                        {
                            if (s.Equals(etiquetaEQU))
                            {
                                ubicacionEtiqueta = nl;
                            }
                            nl++;
                        }
                        cs[numeroSecuencia].dirTabimHex[ubicacionEtiqueta] = num;
                        valorEtiqueta = 0;
                        cs[numeroSecuencia].valorEtiqueta = 0;
                        if (paso == 2)
                        {
                            cs[numeroSecuencia].probando.Add("--");
                        }
                        break;

			case 7:
                        numeroBloque++;
                        numBloque.Add(numeroBloque.ToString());
                        nombreBloques.Add(_input.Lt(2).Text);
                        
                        cs[numeroSecuencia].noEsEtiqueta = 1;
                        if (paso == 1)
                        {
                            cp += 0;
                            cs[numeroSecuencia].cp += 0;
                            cs[numeroSecuencia].conthex.Add(cp.ToString("X"));
                            cs[numeroSecuencia].format.Add("----");
                            cs[numeroSecuencia].mododir.Add("----");
                            /*dirTabsim.Add(cp);
                            dirTabimHex.Add(cp.ToString("X"));*/
                            //conthex.Add(cp.ToString("X"));
                            cs[numeroSecuencia].contProg.Add(cp);

                        }
                        if (paso == 2)
                        {
                            cs[numeroSecuencia].probando.Add("----");
                        }
                        EnterOuterAlt(_localctx, 7);
				{
				State = 145; Match(T__5);
				State = 146; etiqueta();
				State = 147; Match(FINL);
				}
				break;

			case 8:
                        CSECT dd = new CSECT();
                       // cs[numeroSecuencia].nombreSeccion = _input.Lt(1).Text;
                        dd.nombreSeccion = _input.Lt(1).Text;
                        cs.Add(dd);
                        cp = 0;
                        numeroSecuencia++;
                        simbolduplicated = 0;
                        if (paso == 1)
                        {
                            cp += 0;
                            cs[numeroSecuencia].cp += 0;
                            cs[numeroSecuencia].conthex.Add(cp.ToString("X"));
                            cs[numeroSecuencia].format.Add("----");
                            cs[numeroSecuencia].mododir.Add("----");
                            /*dirTabsim.Add(cp);
                            dirTabimHex.Add(cp.ToString("X"));*/
                            //conthex.Add(cp.ToString("X"));
                            contProg.Add(cp);

                        }
                        if (paso == 2)
                        {
                            cs[numeroSecuencia].probando.Add("----");
                        }
                        EnterOuterAlt(_localctx, 8);
				{
				State = 149; Match(ID);
				State = 150; Match(T__6);
				State = 151; Match(FINL);
				}
				break;

			case 9:
                        if (paso == 2)
                        {
                            esWord = 1;
                        }
				EnterOuterAlt(_localctx, 9);
				{
				State = 152; etiqueta();
				State = 153; tipodirectiva();
				State = 154; expresion();
				}
                        if (paso == 2)
                        {
                            string d = completa6(cs[numeroSecuencia].valorEtiqueta.ToString("X"));
                            cs[numeroSecuencia].probando[cs[numeroSecuencia].probando.Count - 1] = d;
                        }
                        
				break;

			case 10:
                        refex = 1;
                        if (paso == 1)
                        {
                            cp += 0;
                            cs[numeroSecuencia].cp += 0;
                            cs[numeroSecuencia].conthex.Add(cp.ToString("X"));
                            cs[numeroSecuencia].format.Add("----");
                            cs[numeroSecuencia].mododir.Add("----");
                            /*dirTabsim.Add(cp);
                            dirTabimHex.Add(cp.ToString("X"));*/
                            //conthex.Add(cp.ToString("X"));
                            cs[numeroSecuencia].contProg.Add(cp);

                        }
                        if (paso == 2)
                        {
                            cs[numeroSecuencia].probando.Add("----");
                        }
                        EnterOuterAlt(_localctx, 10);
				{
				State = 156; direxref();
				}
                        refex = 0;
				break;

			case 11:
                        defex = 1;
                       
                        if (paso == 1)
                        {
                            cp += 0;
                            cs[numeroSecuencia].cp = cp;
                            cs[numeroSecuencia].conthex.Add(cp.ToString("X"));
                            cs[numeroSecuencia].format.Add("----");
                            cs[numeroSecuencia].mododir.Add("----");
                            /*dirTabsim.Add(cp);
                            dirTabimHex.Add(cp.ToString("X"));*/
                            //conthex.Add(cp.ToString("X"));
                            cs[numeroSecuencia].contProg.Add(cp);

                        }
                        if (paso == 2)
                        {
                            cs[numeroSecuencia].probando.Add("----");
                        }
                        EnterOuterAlt(_localctx, 11);
				{
				State = 157; direxdef();
				}
                        defex = 0;
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
                erroresProg(re);
            }
		finally {
			ExitRule();
		}
            verificaExpresion = 0;
            expresionlarga = 0;
            resultadoexpresion = "";
            return _localctx;
	}

	public partial class DirexrefContext : ParserRuleContext {
		public EtiquetaContext[] etiqueta() {
			return GetRuleContexts<EtiquetaContext>();
		}
		public EtiquetaContext etiqueta(int i) {
			return GetRuleContext<EtiquetaContext>(i);
		}
		public DirexrefContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_direxref; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGrammarSICXEVisitor<TResult> typedVisitor = visitor as IGrammarSICXEVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDirexref(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public DirexrefContext direxref() {
		DirexrefContext _localctx = new DirexrefContext(_ctx, State);
		EnterRule(_localctx, 20, RULE_direxref);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 160; Match(T__7);
			State = 161; etiqueta();
			State = 166;
			_errHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(_input,7,_ctx);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
				if ( _alt==1 ) {
					{
					{
					State = 162; Match(T__8);
					State = 163; etiqueta();
					}
					} 
				}
				State = 168;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,7,_ctx);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
                erroresProg(re);
            }
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DirexdefContext : ParserRuleContext {
		public EtiquetaContext[] etiqueta() {
			return GetRuleContexts<EtiquetaContext>();
		}
		public EtiquetaContext etiqueta(int i) {
			return GetRuleContext<EtiquetaContext>(i);
		}
		public DirexdefContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_direxdef; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGrammarSICXEVisitor<TResult> typedVisitor = visitor as IGrammarSICXEVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDirexdef(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public DirexdefContext direxdef() {
		DirexdefContext _localctx = new DirexdefContext(_ctx, State);
		EnterRule(_localctx, 22, RULE_direxdef);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 169; Match(T__9);
			State = 170; etiqueta();
			State = 175;
			_errHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(_input,8,_ctx);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
				if ( _alt==1 ) {
					{
					{
					State = 171; Match(T__8);
					State = 172; etiqueta();
					}
					} 
				}
				State = 177;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,8,_ctx);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
                erroresProg(re);
            }
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TipodirectivaContext : ParserRuleContext {
		public TipodirectivaContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_tipodirectiva; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGrammarSICXEVisitor<TResult> typedVisitor = visitor as IGrammarSICXEVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTipodirectiva(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TipodirectivaContext tipodirectiva() {
		TipodirectivaContext _localctx = new TipodirectivaContext(_ctx, State);
		EnterRule(_localctx, 24, RULE_tipodirectiva);
		int _la;
		try {
                tipo = 1;
                /// Tipotabsim.Add("R");
                if (paso == 1)
                {
                    cs[numeroSecuencia].mododir.Add("----");
                }
                EnterOuterAlt(_localctx, 1);
			{
			State = 178;
			_la = _input.La(1);
                    if (_input.Lt(1).Text == "RESW")
                    {
                        if (paso == 1)
                        {
                            cs[numeroSecuencia].format.Add("----");
                        }
                        if (paso == 2)
                        {
                            cs[numeroSecuencia].probando.Add("----");
                        }

                        int tt, ax;
                        if (_input.Lt(2).Text.Contains("H"))
                        {
                            string[] val = _input.Lt(2).Text.Split('H');
                            if (paso == 1)
                            {
                                ax = Convert.ToInt32(val[0], 16);
                                ax = ax * 3;
                                cs[numeroSecuencia].contProg.Add(cp);
                                cs[numeroSecuencia].conthex.Add(cp.ToString("X"));
                                cp = cp + ax;
                                cs[numeroSecuencia].cp = cp + ax;
                            }

                        }
                        else
                        {
                            if (paso == 1)
                            {
                                tt = int.Parse(_input.Lt(2).Text);
                                cs[numeroSecuencia].contProg.Add(cp);
                                cs[numeroSecuencia].conthex.Add(cp.ToString("X"));
                                tt = tt * 3;
                                cp = cp + tt;
                                cs[numeroSecuencia].cp = cp + tt;
                            }

                        }

                    }
                    if (_input.Lt(1).Text == "WORD")
                    {

                        if (paso == 2 && solounavez == 0)
                        {

                            string dt = obtenConstante(_input.Lt(2).Text);
                            if (dt.Length == 1)
                            {
                                dt = "00000" + dt;
                            }
                            else if (dt.Length == 2)
                            {
                                dt = "0000" + dt;
                            }
                            else if (dt.Length == 3)
                            {
                                dt = "000" + dt;
                            }
                            cs[numeroSecuencia].probando.Add(dt);
                            solounavez = 1;
                        }
                        else
                        {
                            solounavez = 0;
                        }
                        if (paso == 1)
                        {
                            cs[numeroSecuencia].format.Add("----");
                            cs[numeroSecuencia].contProg.Add(cp);
                            cs[numeroSecuencia].conthex.Add(cp.ToString("X"));
                            cp = cp + 3;
                            cs[numeroSecuencia].cp = cp + 3;
                        }

                    }
                    if (_input.Lt(1).Text == "RESB")
                    {
                        if (paso == 2)
                        {
                            cs[numeroSecuencia].probando.Add("----");
                        }
                        if (paso == 1)
                        {
                            cs[numeroSecuencia].format.Add("----");
                            int c = 0;
                            if (_input.Lt(2).Text.Contains("H"))
                            {
                                string[] val = _input.Lt(2).Text.Split('H');
                                int ab;
                                ab = Convert.ToInt32(val[0], 16);
                                cs[numeroSecuencia].contProg.Add(cp);
                                cs[numeroSecuencia].conthex.Add(cp.ToString("X"));
                                cp = cp + ab;
                                cs[numeroSecuencia].cp = cp + ab;
                            }
                            else
                            {
                                // c = Convert.ToInt32(_input.Lt(2).Text, 8);
                                c = Convert.ToInt32(_input.Lt(2).Text);
                               // c = _input.Lt(2).Text.ToString("X");
                                cs[numeroSecuencia].contProg.Add(cp);
                                cs[numeroSecuencia].conthex.Add(cp.ToString("X"));
                                cp = cp + c;
                                cs[numeroSecuencia].cp = cp + c;
                            }
                        }
                    }
                    if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << T__10) | (1L << T__11) | (1L << T__12))) != 0)) ) {
			_errHandler.RecoverInline(this);
			} else {
				if (_input.La(1) == TokenConstants.Eof) {
					matchedEOF = true;
				}

				_errHandler.ReportMatch(this);
				Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
                erroresProg(re);
            }
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class BaseContext : ParserRuleContext {
		public ITerminalNode ID() { return GetToken(GrammarSICXEParser.ID, 0); }
		public BaseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_base; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGrammarSICXEVisitor<TResult> typedVisitor = visitor as IGrammarSICXEVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBase(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public BaseContext @base() {
		BaseContext _localctx = new BaseContext(_ctx, State);
		EnterRule(_localctx, 26, RULE_base);
            if (paso == 1)
            {
                contProg.Add(cp);
                cs[numeroSecuencia].contProg.Add(cp);
                cs[numeroSecuencia].conthex.Add(cp.ToString("X"));
                cs[numeroSecuencia].cp = cp + 0;
                conthex.Add(cp.ToString("X"));
                cp = cp + 0;
            }
            try {
               
                if (paso == 1)
                {
                    cs[numeroSecuencia].mododir.Add("----");
                    cs[numeroSecuencia].format.Add("----");
                }
                if (paso == 2)
                {
                    cs[numeroSecuencia].probando.Add("----");
                }
                EnterOuterAlt(_localctx, 1);
			{
			State = 180; Match(T__13);
			State = 181; Match(ID);
			}
                cs[numeroSecuencia].BASE = buscaTabsim(_input.Lt(2).Text);
            }
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
                erroresProg(re);
            }
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OpdirectivaContext : ParserRuleContext {
		public ITerminalNode CONSTHEX() { return GetToken(GrammarSICXEParser.CONSTHEX, 0); }
		public ITerminalNode CONSTCAD() { return GetToken(GrammarSICXEParser.CONSTCAD, 0); }
		public OpdirectivaContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_opdirectiva; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGrammarSICXEVisitor<TResult> typedVisitor = visitor as IGrammarSICXEVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOpdirectiva(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public OpdirectivaContext opdirectiva() {
		OpdirectivaContext _localctx = new OpdirectivaContext(_ctx, State);
		EnterRule(_localctx, 28, RULE_opdirectiva);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 183;
			_la = _input.La(1);
			if ( !(_la==CONSTHEX || _la==CONSTCAD) ) {
			_errHandler.RecoverInline(this);
			} else {
				if (_input.La(1) == TokenConstants.Eof) {
					matchedEOF = true;
				}

				_errHandler.ReportMatch(this);
				Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
                erroresProg(re);
            }
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OpinstruccionContext : ParserRuleContext {
		public FormatoContext formato() {
			return GetRuleContext<FormatoContext>(0);
		}
		public OpinstruccionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_opinstruccion; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGrammarSICXEVisitor<TResult> typedVisitor = visitor as IGrammarSICXEVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOpinstruccion(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public OpinstruccionContext opinstruccion() {
		OpinstruccionContext _localctx = new OpinstruccionContext(_ctx, State);
		EnterRule(_localctx, 30, RULE_opinstruccion);
		try {
			State = 187;
			_errHandler.Sync(this);
			switch (_input.La(1)) {
			case T__17:
			case T__18:
			case T__19:
			case T__20:
			case T__21:
			case T__22:
			case T__23:
			case T__24:
			case T__25:
			case T__26:
			case T__27:
			case T__28:
			case T__29:
			case T__30:
			case T__31:
			case T__32:
			case T__33:
			case T__34:
			case T__35:
			case T__36:
			case T__37:
			case T__38:
			case T__39:
			case T__40:
			case T__41:
			case T__42:
			case T__43:
			case T__44:
			case T__45:
			case T__46:
			case T__47:
			case T__48:
			case T__49:
			case T__50:
			case T__51:
			case T__52:
			case T__53:
			case T__54:
			case T__55:
			case T__56:
			case T__57:
			case T__58:
			case T__59:
			case T__60:
			case T__61:
			case T__62:
			case T__63:
			case T__64:
			case T__65:
			case T__66:
			case T__67:
			case T__68:
			case T__69:
			case T__70:
			case T__71:
			case T__72:
			case T__73:
			case T__74:
			case MAS:
				EnterOuterAlt(_localctx, 1);
				{
				State = 185; formato();
				}
				break;
			case FINL:
				EnterOuterAlt(_localctx, 2);
				{
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
                erroresProg(re);
            }
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FormatoContext : ParserRuleContext {
		public F1Context f1() {
			return GetRuleContext<F1Context>(0);
		}
		public F2Context f2() {
			return GetRuleContext<F2Context>(0);
		}
		public F3Context f3() {
			return GetRuleContext<F3Context>(0);
		}
		public F4Context f4() {
			return GetRuleContext<F4Context>(0);
		}
		public FormatoContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_formato; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGrammarSICXEVisitor<TResult> typedVisitor = visitor as IGrammarSICXEVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFormato(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public FormatoContext formato() {
		FormatoContext _localctx = new FormatoContext(_ctx, State);
		EnterRule(_localctx, 32, RULE_formato);
		try {
			State = 193;
			_errHandler.Sync(this);
			switch (_input.La(1)) {
			case T__22:
			case T__23:
			case T__24:
			case T__25:
			case T__26:
			case T__27:
				EnterOuterAlt(_localctx, 1);
				{
				State = 189; f1();
				}
				break;
			case T__17:
			case T__18:
			case T__19:
			case T__20:
			case T__21:
			case T__28:
			case T__29:
			case T__30:
			case T__31:
			case T__32:
			case T__33:
				EnterOuterAlt(_localctx, 2);
				{
				State = 190; f2();
				}
				break;
			case T__34:
			case T__35:
			case T__36:
			case T__37:
			case T__38:
			case T__39:
			case T__40:
			case T__41:
			case T__42:
			case T__43:
			case T__44:
			case T__45:
			case T__46:
			case T__47:
			case T__48:
			case T__49:
			case T__50:
			case T__51:
			case T__52:
			case T__53:
			case T__54:
			case T__55:
			case T__56:
			case T__57:
			case T__58:
			case T__59:
			case T__60:
			case T__61:
			case T__62:
			case T__63:
			case T__64:
			case T__65:
			case T__66:
			case T__67:
			case T__68:
			case T__69:
			case T__70:
			case T__71:
			case T__72:
			case T__73:
			case T__74:
				EnterOuterAlt(_localctx, 3);
				{
				State = 191; f3();
				}
				break;
			case MAS:
				EnterOuterAlt(_localctx, 4);
				{
				State = 192; f4();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
                erroresProg(re);
            }
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class F1Context : ParserRuleContext {
		public Codop1Context codop1() {
			return GetRuleContext<Codop1Context>(0);
		}
		public F1Context(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_f1; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGrammarSICXEVisitor<TResult> typedVisitor = visitor as IGrammarSICXEVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitF1(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public F1Context f1() {
		F1Context _localctx = new F1Context(_ctx, State);
		EnterRule(_localctx, 34, RULE_f1);
		try {
                if (paso == 1)
                {
                    cs[numeroSecuencia].format.Add("f1");
                    cs[numeroSecuencia].mododir.Add("----");
                    cs[numeroSecuencia].contProg.Add(cp);
                    cs[numeroSecuencia].conthex.Add(cp.ToString("X"));
                    cp = cp + 1;
                    cs[numeroSecuencia].cp = cp + 1;
                }
                if (paso == 2)
                {
                    string s = _input.Lt(1).Text;
                    s = checaNemonico(s);
                    cs[numeroSecuencia].probando.Add(s);
                }
                EnterOuterAlt(_localctx, 1);
			{
			State = 195; codop1();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
                erroresProg(re);
            }
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class F2Context : ParserRuleContext {
		public Subf2aContext subf2a() {
			return GetRuleContext<Subf2aContext>(0);
		}
		public Subf2bContext subf2b() {
			return GetRuleContext<Subf2bContext>(0);
		}
		public Subf2cContext subf2c() {
			return GetRuleContext<Subf2cContext>(0);
		}
		public Subf2dContext subf2d() {
			return GetRuleContext<Subf2dContext>(0);
		}
		public F2Context(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_f2; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGrammarSICXEVisitor<TResult> typedVisitor = visitor as IGrammarSICXEVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitF2(this);
			else return visitor.VisitChildren(this);
		}
	}

        public string buscaRegistro(string reg)
        {
            string m = "";
            switch (reg)
            {
                case "A":
                    m = "0";
                    break;
                case "X":
                    m = "1";
                    break;
                case "L":
                    m = "2";
                    break;
                case "B":
                    m = "3";
                    break;
                case "S":
                    m = "4";
                    break;
                case "T":
                    m = "5";
                    break;
                case "":
                    m = "0";
                    break;
                case " ":
                    m = "0";
                    break;
            }
            return m;
        }

        [RuleVersion(0)]
	public F2Context f2() {
		F2Context _localctx = new F2Context(_ctx, State);
		EnterRule(_localctx, 36, RULE_f2);
		try {
                if (paso == 1)
                {
                    cs[numeroSecuencia].format.Add("f2");
                    cs[numeroSecuencia].mododir.Add("----");
                    cs[numeroSecuencia].contProg.Add(cp);
                    cs[numeroSecuencia].conthex.Add(cp.ToString("X"));
                    cp = cp + 2;
                    cs[numeroSecuencia].cp = cp + 2;
                }
                if (paso == 2)
                {
                    string s = _input.Lt(1).Text;
                    s = checaNemonico(s);
                    string b = buscaRegistro(_input.Lt(2).Text);
                    string c = buscaRegistro(_input.Lt(4).Text);
                    string obj2 = s + b + c;
                    if (obj2.Length == 3)
                    {
                        obj2 = obj2 + "0";
                    }
                    cs[numeroSecuencia].probando.Add(obj2);
                }
                State = 201;
			_errHandler.Sync(this);
			switch (_input.La(1)) {
			case T__28:
			case T__29:
			case T__30:
			case T__31:
			case T__32:
			case T__33:
				EnterOuterAlt(_localctx, 1);
				{
				State = 197; subf2a();
				}
				break;
			case T__17:
			case T__18:
				EnterOuterAlt(_localctx, 2);
				{
				State = 198; subf2b();
				}
				break;
			case T__19:
			case T__20:
				EnterOuterAlt(_localctx, 3);
				{
				State = 199; subf2c();
				}
				break;
			case T__21:
				EnterOuterAlt(_localctx, 4);
				{
				State = 200; subf2d();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
                erroresProg(re);
            }
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class F3Context : ParserRuleContext {
		public Simple3Context simple3() {
			return GetRuleContext<Simple3Context>(0);
		}
		public Indirecto3Context indirecto3() {
			return GetRuleContext<Indirecto3Context>(0);
		}
		public Inmediato3Context inmediato3() {
			return GetRuleContext<Inmediato3Context>(0);
		}
		public F3Context(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_f3; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGrammarSICXEVisitor<TResult> typedVisitor = visitor as IGrammarSICXEVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitF3(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public F3Context f3() {
		F3Context _localctx = new F3Context(_ctx, State);
		EnterRule(_localctx, 38, RULE_f3);
		try {
			State = 206;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,12,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 203; simple3();
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 204; indirecto3();
				}
				break;

			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 205; inmediato3();
				}
				break;
			}
                if (form4 == 1)
                {
                    form4 = 0;
                    //format.Add("f4");
                }
                else
                {
                    if (paso == 1)
                    {
                        cs[numeroSecuencia].format.Add("f3");

                        cs[numeroSecuencia].contProg.Add(cp);
                        cs[numeroSecuencia].conthex.Add(cp.ToString("X"));
                        cp = cp + 3;
                        cs[numeroSecuencia].cp = cp + 3;
                    }

                }
            }
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
                erroresProg(re);
            }
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class F4Context : ParserRuleContext {
		public F3Context f3() {
			return GetRuleContext<F3Context>(0);
		}
		public F4Context(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_f4; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGrammarSICXEVisitor<TResult> typedVisitor = visitor as IGrammarSICXEVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitF4(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public F4Context f4() {
		F4Context _localctx = new F4Context(_ctx, State);
		EnterRule(_localctx, 40, RULE_f4);
		try {
                int x = 0;

                cs[numeroSecuencia].verificaExpresion = 1;
                format4 = 1;
                form4 = 1;
                EnterOuterAlt(_localctx, 1);
			{
			State = 208; Match(MAS);
			State = 209; f3();
			}
                if (paso == 1)
                {
                    cs[numeroSecuencia]. format.Add("f4");
                    cs[numeroSecuencia].contProg.Add(cp);
                    cs[numeroSecuencia].conthex.Add(cp.ToString("X"));
                    cp = cp + 4;
                    cs[numeroSecuencia].cp = cp + 4;
                }
            }
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
                erroresProg(re);
            }
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Simple3Context : ParserRuleContext {
		public Codop3Context codop3() {
			return GetRuleContext<Codop3Context>(0);
		}
		public ITerminalNode ID() { return GetToken(GrammarSICXEParser.ID, 0); }
		public ITerminalNode NUM() { return GetToken(GrammarSICXEParser.NUM, 0); }
		public ExpresionContext expresion() {
			return GetRuleContext<ExpresionContext>(0);
		}
		public Simple3Context(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_simple3; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGrammarSICXEVisitor<TResult> typedVisitor = visitor as IGrammarSICXEVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSimple3(this);
			else return visitor.VisitChildren(this);
		}
	}

        public string casoCSimpleF4(string v1, string v2, string bandera)
        {
            string codobj;
            char s = v1[0];
            char n = v1[1];
            string d2 = hexToBin(n);
            string d3 = d2 + "11";
            string d4 = bandera;
            string d31 = binTohex(d3);
            if (v2.Length == 3)
            {
                v2 = "00" + v2;
            }
            if (v2.Length == 4)
            {
                v2 = "0" + v2;
            }
            codobj = s + d31 + "9" + v2;
            //probando.Add("s"+s+"d3"+d3+"d31"+d31+"d4"+d4+"v2");
            return codobj;
        }

        public string convierteObjSimpleF4(string v1, string v2, string bandera)
        {
            string codobj;
            char s = v1[0];
            char n = v1[1];
            string d2 = hexToBin(n);
            string d3 = d2 + "11";
            string d4 = bandera;
            string d31 = binTohex(d3);
            if(v2.Length==1)
            {
                v2 = "0000" + v2;
            }
            if (v2.Length == 2)
            {
                v2 = "000" + v2;
            }
            if (v2.Length == 3)
            {
                v2 = "00" + v2;
            }
            if (v2.Length == 4)
            {
                v2 = "0" + v2;
            }
            codobj = s + d31 + d4 + v2;
            //probando.Add("s"+s+"d3"+d3+"d31"+d31+"d4"+d4+"v2");
            return codobj;
        }

        [RuleVersion(0)]

     public string completaConstanteF4(string s)
        {
            switch (s.Length)
            {
                case 1:
                    s = "0000" + s;
                    break;
                case 2:
                    s = "000" + s;
                    break;
                case 3:
                    s = "00" + s;
                    break;
                case 4:
                    s = "0" + s;
                    break;
            }
            return s;
        }
	public Simple3Context simple3() {
		Simple3Context _localctx = new Simple3Context(_ctx, State);
		EnterRule(_localctx, 42, RULE_simple3);
            string x, y, z;
            try {
                if (paso == 1)
                {
                    cs[numeroSecuencia].mododir.Add("Simple");
                }
                State = 230;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,13,_ctx) ) {
			case 1:
                        x = _input.Lt(1).Text;
                        int linea = _input.Lt(1).Line;
                        y = _input.Lt(2).Text;
                        EnterOuterAlt(_localctx, 1);
				{
				State = 211; codop3();
				State = 212; Match(ID);
				}
                        if (paso == 2)
                        {
                            if (format4 == 1)
                            {
                                format4 = 0;
                                z = _input.Lt(3).Text;
                                if (cs[numeroSecuencia].verificaExpresion == 1 || cs[numeroSecuencia].verificaExpresion == 0)
                                {
                                    z = cs[numeroSecuencia].valorEtiqueta.ToString("X");
                                }
                                string a = checaNemonico(x);
                                string b = obtenConstante(_input.Lt(3).Text);
                                string zn = completaConstanteF4(z);
                                string c = convierteObjSimpleF4(a, zn, "1");
                                int nn = verificaReferencia(y);
                                if (nn == 1)
                                {
                                    cs[numeroSecuencia].probando.Add(c+"*SE");
                                    cs[numeroSecuencia].SimbolosWord.Add(y);
                                }
                                if (nn == 0)
                                {
                                    cs[numeroSecuencia].probando.Add(c + "*");
                                }

                            }
                            else
                            {
                                string de = checaNemonico(x);
                                string ef = _input.Lt(2).Text;
                                string dirtab = buscaTabsim(y) + "H";
                                if (dirtab.Length == 1)
                                {
                                    dirtab = "00" + dirtab;
                                }
                                if (dirtab.Length == 2)
                                {
                                    dirtab = "0" + dirtab;
                                }
                                string codi = simpleM(x, y, linea);


                                cs[numeroSecuencia].probando.Add(codi);

                                //string codi = inmediatosimpleC(de, dirtab);

                                //probando.Add(_input.Lt(1) + "Simple f3 m");

                            }
                        }
                        break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 214; codop3();
				State = 215; Match(NUM);
				}
                        if (paso == 2)
                        {
                            string d = checaNemonico(_input.Lt(1).Text);
                            //string e = _input.Lt(2).Text;
                            string cod = inmediatosimpleC(d, _input.Lt(2).Text, "0");
                            cs[numeroSecuencia].probando.Add(cod);
                        }
                        break;

			case 3:
                        y = _input.Lt(2).Text;
                        x = _input.Lt(1).Text;
                        EnterOuterAlt(_localctx, 3);
				{
				State = 217; codop3();
				State = 218; Match(NUM);
				State = 219; Match(T__8);
				State = 220; Match(T__14);
				}
                        if (paso == 2)
                        {
                            if (format4 == 1)
                            {
                                format4 = 0;

                                string a = checaNemonico(x);
                                string b = obtenConstante(y);

                                string c = casoCSimpleF4(a, b, "9");
                                cs[numeroSecuencia].probando.Add(x+c);
                            }
                            else
                            {
                                string d;
                                d = checaNemonico(x);
                                // e = _input.Lt(3).Text;
                                string cod = inmediatosimpleC(d, y, "8");

                                cs[numeroSecuencia].probando.Add(cod);

                            }
                        }
                        break;

			case 4:
                        x = _input.Lt(1).Text;
                        int lin = _input.Lt(1).Line;
                        y = _input.Lt(2).Text;
                        z = _input.Lt(3).Text;
                        EnterOuterAlt(_localctx, 4);
				{
				State = 222; codop3();
				State = 223; Match(ID);
				State = 224; Match(T__8);
				State = 225; Match(T__14);
				}
                        if (paso == 2)
                        {
                            if (format4 == 1)
                            {
                                format4 = 0;
                                
                                string a = checaNemonico(x);
                                string b = buscaTabsim(y);
                                int bs = verificaReferencia(y);

                                string c = convierteObjSimpleF4(a, b, "9");
                                if (bs == 1)
                                {
                                    cs[numeroSecuencia].probando.Add(c+"*SE");
                                    cs[numeroSecuencia].SimbolosWord.Add(y);
                                }
                                if (bs == 0)
                                {
                                    cs[numeroSecuencia].probando.Add(c + "*R");
                                }
                            }
                            else
                            {
                                string de = checaNemonico(x);
                                string ef = _input.Lt(2).Text;
                                string dirtab = buscaTabsim(y);
                                if (dirtab.Length == 1)
                                {
                                    dirtab = "00" + dirtab;
                                }
                                if (dirtab.Length == 2)
                                {
                                    dirtab = "0" + dirtab;
                                }
                                string codi = simpleM2(x, y, lin);


                                cs[numeroSecuencia].probando.Add(codi);

                                //string codi = inmediatosimpleC(de, dirtab);

                                //probando.Add(_input.Lt(1) + "Simple f3 m");

                            }
                        }
                
                break;

			case 5:
                        x = _input.Lt(1).Text;
                        int linea2 = _input.Lt(1).Line;
                        y = _input.Lt(2).Text;
                        EnterOuterAlt(_localctx, 5);
				{
				State = 227; codop3();
				State = 228; expresion();
				}
                        if (paso == 2)
                        {
                            if (format4 == 1)
                            {
                                z = _input.Lt(3).Text;
                                if (cs[verificaExpresion].verificaExpresion == 1)
                                {

                                }
                                format4 = 0;

                                string a = checaNemonico(_input.Lt(1).Text);
                                string b = obtenConstante(_input.Lt(3).Text);

                                string c = convierteObjSimpleF4(x, z, "1");
                                cs[numeroSecuencia].probando.Add(c + "hs");
                            }
                            else
                            {
                                string de = checaNemonico(x);
                                string ef = _input.Lt(2).Text;
                                string dirtab = buscaTabsim(y) + "H";
                                if (dirtab.Length == 1)
                                {
                                    dirtab = "00" + dirtab;
                                }
                                if (dirtab.Length == 2)
                                {
                                    dirtab = "0" + dirtab;
                                }
                                string codi = simpleM(x, y, linea2);


                                cs[numeroSecuencia].probando.Add(codi);

                                //string codi = inmediatosimpleC(de, dirtab);

                                //probando.Add(_input.Lt(1) + "Simple f3 m");

                            }
                        }
                        break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
                if (paso == 2)
                {
                    cs[numeroSecuencia].probando.Add("Direccionamiento simple no encontrado");
                }
                erroresProg(re);
            }
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Indirecto3Context : ParserRuleContext {
		public Codop3Context codop3() {
			return GetRuleContext<Codop3Context>(0);
		}
		public ITerminalNode NUM() { return GetToken(GrammarSICXEParser.NUM, 0); }
		public ITerminalNode ID() { return GetToken(GrammarSICXEParser.ID, 0); }
		public ExpresionContext expresion() {
			return GetRuleContext<ExpresionContext>(0);
		}
		public Indirecto3Context(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_indirecto3; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGrammarSICXEVisitor<TResult> typedVisitor = visitor as IGrammarSICXEVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIndirecto3(this);
			else return visitor.VisitChildren(this);
		}
	}

        public string completaEtiqueta(string s)
        {
            string result = "";
            switch (s.Length)
            {
                case 1:
                    result = s + "     ";
                    break;
                case 2:
                    result = s + "    ";
                    break;
                case 3:
                    result = s + "   ";
                    break;
                case 4:
                    result = s + "  ";
                    break;
                case 5:
                    result = s + " ";
                    break;
                case 6:
                    result = s;
                    break;

            }
            return result;
        }

        [RuleVersion(0)]
	public Indirecto3Context indirecto3() {
		Indirecto3Context _localctx = new Indirecto3Context(_ctx, State);
		EnterRule(_localctx, 44, RULE_indirecto3);
		try {
                if (paso == 1)
                {
                    cs[numeroSecuencia].mododir.Add("indirecto");
                }
                State = 244;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,14,_ctx) ) {
			case 1:
                        string xs = _input.Lt(1).Text;
                        string ys = _input.Lt(3).Text;
                        if (paso == 2)
                        {
                            string obd = checaNemonico(xs);
                            string codob = indirectoC(obd, ys);
                            cs[numeroSecuencia].probando.Add(codob);
                        }
                        EnterOuterAlt(_localctx, 1);
				{
				State = 232; codop3();
				State = 233; Match(T__15);
				State = 234; Match(NUM);
				}
				break;

			case 2:
                        string x = _input.Lt(1).Text;
                        string y = _input.Lt(3).Text;
                        if (paso == 2)
                        {

                            if (format4 == 1)
                            {

                                format4 = 0;

                                string a = checaNemonico(x);
                                //string b = obtenConstante(y);
                                string b = buscaTabsim(y);
                                string c = convierteObjIndiF4(a, b);
                                int tiporef = verificaReferencia(y);
                                
                                if (tiporef == 1)
                                {
                                    cs[numeroSecuencia].probando.Add(c + "*SE");
                                    cs[numeroSecuencia].SimbolosWord.Add(completaEtiqueta(y));
                                }
                                else
                                {
                                    cs[numeroSecuencia].probando.Add(c + "*");
                                }
                               
                            }
                            else
                            {
                                string d = checaNemonico(x);
                                string e = _input.Lt(2).Text;
                                string cod = indirectoM(x, y, _input.Lt(1).Line);
                                cs[numeroSecuencia].probando.Add(cod);

                            }
                        }
                        EnterOuterAlt(_localctx, 2);
				{
				State = 236; codop3();
				State = 237; Match(T__15);
				State = 238; Match(ID);
				}
				break;

			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 240; codop3();
				State = 241; Match(T__15);
				State = 242; expresion();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
                erroresProg(re);
            }
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Inmediato3Context : ParserRuleContext {
		public Codop3Context codop3() {
			return GetRuleContext<Codop3Context>(0);
		}
		public ITerminalNode NUM() { return GetToken(GrammarSICXEParser.NUM, 0); }
		public ITerminalNode ID() { return GetToken(GrammarSICXEParser.ID, 0); }
		public ExpresionContext expresion() {
			return GetRuleContext<ExpresionContext>(0);
		}
		public Inmediato3Context(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_inmediato3; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGrammarSICXEVisitor<TResult> typedVisitor = visitor as IGrammarSICXEVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitInmediato3(this);
			else return visitor.VisitChildren(this);
		}
	}

        public string checaTabSim(string pos)
        {
            int m = 0;

            for (int j = 0; j < cs[numeroSecuencia].tabsimb.Count; j++)
            {
                if (pos == cs[numeroSecuencia].tabsimb[j])
                {
                    m = j;
                    //probando.Add(_input.Lt(1).Text + CodOp[m] + "->\t " + _input.Lt(2).Text + " ");
                }
            }

            return cs[numeroSecuencia].dirTabimHex[m];
        }

        public string checaNemonico(string dato)
        {
            int m = -1;
            for (int i = 0; i < nemonicos.Length; i++)
            {
                if (nemonicos[i] == dato)
                {
                    m = i;

                }

            }
            if (m != -1)
            {
                return CodOp[m];
            }
            else
            {
                return "Error";
            }

        }

        public string obtenConstante(string c)
        {
            string[] val = new string[1];
            if (c.Contains("H"))
            {
                val = c.Split('H');


            }
            else
            {
                val[0] = c;
            }
            return val[0];
        }

        public string hexToBin(char hex)
        {
            string bin = "";
            switch (hex)
            {

                case '0':
                    bin = "00";
                    break;
                case '8':
                    bin = "10";
                    break;
                case '4':
                    bin = "01";
                    break;
                case 'C':
                    bin = "11";
                    break;

            }
            return bin;
        }

        public string binTohex(string bin)
        {
            string dato = "";
            switch (bin)
            {
                case "0000":
                    bin = "0";
                    break;
                case "0001":
                    bin = "1";
                    break;
                case "0010":
                    bin = "2";
                    break;
                case "0011":
                    bin = "3";
                    break;
                case "0100":
                    bin = "4";
                    break;
                case "0101":
                    bin = "5";
                    break;
                case "0110":
                    bin = "6";
                    break;
                case "0111":
                    bin = "7";
                    break;
                case "1000":
                    bin = "8";
                    break;
                case "1001":
                    bin = "9";
                    break;
                case "1010":
                    bin = "A";
                    break;
                case "1011":
                    bin = "B";
                    break;
                case "1100":
                    bin = "C";
                    break;
                case "1101":
                    bin = "D";
                    break;
                case "1110":
                    bin = "E";
                    break;
                case "1111":
                    bin = "F";
                    break;

            }
            return bin;
        }

        public string convierteObjF4(string v1, string v2)
        {
            string codobj;
            char s = v1[0];
            char n = v1[1];
            string d2 = hexToBin(n);
            string d3 = d2 + "01";
            string d4 = "1";
            string d31 = binTohex(d3);
            if (v2.Length == 3)
            {
                v2 = "00" + v2;
            }
            if (v2.Length == 4)
            {
                v2 = "0" + v2;
            }
            if (v2.Length == 2)
            {
                v2 = "000" + v2;
            }
            if (v2.Length == 1)
            {
                v2 = "0000" + v2;
            }

            codobj = s + d31 + d4 + v2;
            //probando.Add("s"+s+"d3"+d3+"d31"+d31+"d4"+d4+"v2");
            return codobj;
        }

        public string convierteObjIndiF4(string v1, string v2)
        {
            string codobj;
            char s = v1[0];
            char n = v1[1];
            string d2 = hexToBin(n);
            string d3 = d2 + "10";
            string d4 = "1";
            string d31 = binTohex(d3);
            if (v2.Length == 3)
            {
                v2 = "00" + v2;
            }
            if (v2.Length == 4)
            {
                v2 = "0" + v2;
            }
            if (v2.Length == 2)
            {
                v2 = "000" + v2;
            }
            if (v2.Length == 1)
            {
                v2 = "0000" + v2;
            }

            codobj = s + d31 + d4 + v2;
            return codobj;
        }

        public string buscaCP(int nlinea)
        {
            string valcp = "";
            try
            {
                valcp = cs[numeroSecuencia].conthex[nlinea];
                
            }
            catch (Exception e)
            {
                valcp = "0";
            }
            return valcp;
        }

        public int checarelCP(int nlinea, string etiq)
        {
            string desp = "";
            int despl = 0;
            string cp = buscaCP(nlinea);
            string TA = buscaTabsim(etiq);
            
            despl = Convert.ToInt32(TA, 16) - Convert.ToInt32(cp, 16);
            //int numeroDecimal = Convert.ToInt32(numeroHexadecimal, 16);
            return despl;
        }
        public int checarelB(string etiq)
        {
            string dir = "";
            string desp = "";
            int despl = 0;

            string TA = buscaTabsim(etiq);

            despl = Convert.ToInt32(TA, 16) - Convert.ToInt32(cs[numeroSecuencia].BASE, 16);
            //int numeroDecimal = Convert.ToInt32(numeroHexadecimal, 16);
            return despl;

        }

        public string indirectoM(string d1, string d2, int ln)
        {
            string n = "";
            string m = "";
            string par3 = "";
            d1 = checaNemonico(d1);
            char a = d1[0];
            char b = d1[1];
            string r = hexToBin(b);
            string p2 = r + "10";
            string p3 = binTohex(p2);

            int al = checarelCP(ln, d2);
            string desp = "";
            if (al > -2048 && al < 2048)
            {
                string dat = al.ToString("X");

                int bb = 0;
                int mr = 0;
                foreach (char nx in dat)
                {
                    bb++;
                    if (bb > 5)
                    {
                        mr = 1;
                        desp = desp + nx;
                    }
                }
                if (mr == 0)
                {
                    desp = dat;
                }
                switch (desp.Length)
                {
                    case 1:
                        desp = "00" + desp;
                        break;
                    case 2:
                        desp = "0" + "desp";
                        break;
                }
                par3 = "2";
            }
            else
            {
                int abase = checarelB(d2);
                if (abase >= 0 && abase < 4096)
                {
                    string dat = abase.ToString("X");

                    int bb = 0;
                    int dz = 0;
                    foreach (char nx in dat)
                    {
                        bb++;
                        if (bb > 5)
                        {
                            dz = 1;
                            desp = desp + nx;
                        }
                    }
                    if (dz == 0)
                    {
                        desp = dat;
                    }
                    switch (desp.Length)
                    {
                        case 1:
                            desp = "00" + desp;
                            break;
                        case 2:
                            desp = "0" + desp;
                            break;
                    }
                    par3 = "4";
                }
                else
                {
                    n = "Error no es relativo a CP o B";
                }
            }

            //string desp = dat[dat.Length - 2].ToString() +dat[dat.Length - 1].ToString()+ dat[dat.Length-1].ToString();
            //string desp = dat.Substring(dat.Length-3,3);


            if (m.Length == 1)
            {
                m = "00" + m;
            }
            else if (m.Length == 2)
            {
                m = "0" + m;
            }
            n = a + p3 + par3 + desp;
            return n;
        }

        public string simpleM(string d1, string d2, int ln)
        {
            string n = "";
            string m = "";
            string par3 = "";
            d1 = checaNemonico(d1);
            char a = d1[0];
            char b = d1[1];
            string r = hexToBin(b);
            string p2 = r + "11";
            string p3 = binTohex(p2);

            int al = checarelCP(ln, d2);
            string desp = "";
            if (al > -2048 && al < 2048)
            {
                string dat = al.ToString("X");

                int bb = 0;
                int croc = 0;
                foreach (char nx in dat)
                {
                    bb++;
                    if (bb > 5)
                    {
                        croc = 1;
                        desp = desp + nx;
                    }
                }
                if (croc == 0)
                {
                    desp = dat;
                }
                switch (desp.Length)
                {
                    case 1:
                        desp = "00" + desp;
                        break;
                    case 2:
                        desp = "0" + desp;
                        break;
                }
                par3 = "2";
            }
            else
            {
                int abase = checarelB(d2);
                if (abase >= 0 && abase < 4096)
                {
                    string dat = abase.ToString("X");

                    int bb = 0;
                    int crom = 0;
                    foreach (char nx in dat)
                    {
                        bb++;
                        if (bb > 5)
                        {
                            crom = 1;
                            desp = desp + nx;
                        }
                    }
                    if (crom == 0)
                    {
                        desp = dat;
                    }
                    switch (desp.Length)
                    {
                        case 1:
                            desp = "00" + desp;
                            break;
                        case 2:
                            desp = "0" + desp;
                            break;
                    }
                    par3 = "4";
                }
                else
                {
                    n = "Error no es relativo a CP o B";
                }
            }

            //string desp = dat[dat.Length - 2].ToString() +dat[dat.Length - 1].ToString()+ dat[dat.Length-1].ToString();
            //string desp = dat.Substring(dat.Length-3,3);


            if (m.Length == 1)
            {
                m = "00" + m;
            }
            else if (m.Length == 2)
            {
                m = "0" + m;
            }
            n = a + p3 + par3 + desp;
            return n;
        }

        public string simpleM2(string d1, string d2, int ln)
        {
            string n = "";
            string m = "";
            string par3 = "";
            d1 = checaNemonico(d1);
            char a = d1[0];
            char b = d1[1];
            string r = hexToBin(b);
            string p2 = r + "11";
            string p3 = binTohex(p2);
            int al = checarelCP(ln, d2);
            string desp = "";
            if (al > -2048 && al < 2048)
            {
                string dat = al.ToString("X");

                int bb = 0;
                int nz = 0;
                foreach (char nx in dat)
                {
                    bb++;
                    if (bb > 5)
                    {
                        nz = 1;
                        desp = desp + nx;
                    }
                }
                if (nz == 0)
                {
                    desp = dat;
                }
                switch (desp.Length)
                {
                    case 1:
                        desp = "00" + desp;
                        break;
                    case 2:
                        desp = "0" + desp;
                        break;
                }
                par3 = "A";
            }
            else
            {
                int abase = checarelB(d2);
                if (abase >= 0 && abase < 4096)
                {
                    string dat = abase.ToString("X");

                    int bb = 0;
                    int nrz = 0;
                    foreach (char nx in dat)
                    {
                        bb++;
                        if (bb > 5)
                        {
                            nrz = 1;
                            desp = desp + nx;
                        }
                    }
                    if (nrz == 0)
                    {
                        desp = dat;
                    }
                    par3 = "C";
                }
                else
                {
                    n = "Error no es relativo a CP o B";
                }
            }

            //string desp = dat[dat.Length - 2].ToString() +dat[dat.Length - 1].ToString()+ dat[dat.Length-1].ToString();
            //string desp = dat.Substring(dat.Length-3,3);


            if (m.Length == 1)
            {
                m = "00" + m;
            }
            else if (m.Length == 2)
            {
                m = "0" + m;
            }
            n = a + p3 + par3 + desp;
            return n;
        }

        public string inmediatosimpleC(string d1, string d2, string cass)
        {
            string n = "";
            string sr = cass;
            string m;
            char a = d1[0];
            char b = d1[1];
            string r = hexToBin(b);
            string p2 = r + "11";
            string p3 = binTohex(p2);
            if (d2.Contains("H"))
            {
                m = obtenConstante(d2);
            }
            else
            {
                int dd = Convert.ToInt32(d2);
                m = dd.ToString("X");
            }
            if (m.Length == 1)
            {
                m = "00" + m;
            }
            else if (m.Length == 2)
            {
                m = "0" + m;
            }
            n = a + p3 + cass + m;
            return n;
        }
        public string indirectoC(string d1, string d2)
        {
            string n = "";
            string m;
            char a = d1[0];
            char b = d1[1];
            string r = hexToBin(b);
            string p2 = r + "10";
            string p3 = binTohex(p2);
            if (d2.Contains("H"))
            {
                m = obtenConstante(d2);
            }
            else
            {
                int dd = Convert.ToInt32(d2);
                m = dd.ToString("X");
            }
            if (m.Length == 1)
            {
                m = m + "00";
            }
            else if (m.Length == 2)
            {
                m = m + "0";
            }
            n = a + p3 + "0" + m;
            return n;
        }
        public string inmediatoC(string d1, string d2)
        {
            string n = "";
            string m;
            char a = d1[0];
            char b = d1[1];
            string r = hexToBin(b);
            string p2 = r + "01";
            string p3 = binTohex(p2);
            if (d2.Contains("H"))
            {
                m = obtenConstante(d2);
            }
            else
            {
                int dd = Convert.ToInt32(d2);
                m = dd.ToString("X");
            }
            if (m.Length == 1)
            {
                m = m + "00";
            }
            else if (m.Length == 2)
            {
                m = m + "0";
            }
            n = a + p3 + "0" + m;
            return n;
        }
        public string buscaTabsim(string etiqueta)
        {
            string TA = "E";
            for (int i = 0; i < cs[numeroSecuencia].tabsimb.Count; i++)
            {
                if (etiqueta == cs[numeroSecuencia].tabsimb[i])
                {
                    TA = cs[numeroSecuencia].dirTabimHex[i];
                }
            }
            return TA;
        }

        public int verificaReferencia(string etiqueta)
        {
            int refi= 0;
            string ss = "";
            for (int i = 0; i < cs[numeroSecuencia].tabsimb.Count; i++)
            {
                if (etiqueta == cs[numeroSecuencia].tabsimb[i])
                {
                    
                    ss = cs[numeroSecuencia].referenciaExterna[i];
                    if(ss.Equals("Si"))
                        {
                        refi = 1;
                    }
                    if (ss.Equals("No"))
                    {
                        refi = 0;
                    }



                }
            }
            return refi;
        }
        public string inmediatoM(string d1, string d2, int Line)
        {
            string TA = "";
            string n = "";
            string par3 = "";
            string m;
            
            char a = d1[0];
            char b = d1[1];
            string r = hexToBin(b);
            string p2 = r + "01";
            string desp = "";
            string p3 = binTohex(p2);
            TA = buscaTabsim(d2);
            if (TA == "E")
            {
                string pp = binTohex(p2);
                cs[numeroSecuencia].Errorespaso2.Add(Line.ToString() + "  Error simbolo no existe");
                n = a + pp + "6" + "FFF";

            }
            else
            {
                int al = checarelCP(Line+1, d2);
                
                if (al > -2048 && al < 2048)
                {
                    string dat = al.ToString("X");

                    int bb = 0;
                    int nz = 0;
                    foreach (char nx in dat)
                    {
                        bb++;
                        if (bb > 5)
                        {
                            nz = 1;
                           // desp = desp + nx;
                        }
                    }
                    if (nz == 0)
                    {
                        desp = dat;
                    }
                    switch (desp.Length)
                    {
                        case 1:
                            desp = "00" + desp;
                            break;
                        case 2:
                            desp = "0" + desp;
                            break;
                    }
                    par3 = "2";
                }
                else
                {
                    int abase = checarelB(d2);
                    if (abase >= 0 && abase < 4096)
                    {
                        string dat = abase.ToString("X");

                        int bb = 0;
                        int nrz = 0;
                        foreach (char nx in dat)
                        {
                            bb++;
                            if (bb > 5)
                            {
                                nrz = 1;
                                desp = desp + nx;
                            }
                        }
                        if (nrz == 0)
                        {
                            desp = dat;
                        }
                        par3 = "4";
                    }
                    else
                    {
                        n = "Error no es relativo a CP o B";
                    }
                }
              
            }
            n = a + p3 + par3 + desp;
            return n;
        }

        [RuleVersion(0)]
	public Inmediato3Context inmediato3() {
            string x, y;
            Inmediato3Context _localctx = new Inmediato3Context(_ctx, State);
		EnterRule(_localctx, 46, RULE_inmediato3);
		try {
                if (paso == 1)
                {
                    cs[numeroSecuencia].mododir.Add("inmediato");
                }
                State = 258;
			_errHandler.Sync(this);
                int m = 0;
                switch ( Interpreter.AdaptivePredict(_input,15,_ctx) ) {
			case 1:
                        x = _input.Lt(1).Text;
                        y = _input.Lt(2).Text;
                        if (paso == 2)
                        {
                            if (format4 == 1)
                            {
                                format4 = 0;

                                string a = checaNemonico(x);
                                string b = obtenConstante(_input.Lt(3).Text);

                                string c = convierteObjF4(a, b);
                                cs[numeroSecuencia].probando.Add(c);
                            }
                            else
                            {
                                string d = checaNemonico(x);
                                string e = _input.Lt(3).Text;
                                string cod = inmediatoC(d, e);
                                cs[numeroSecuencia].probando.Add(cod);

                            }
                        }
                        EnterOuterAlt(_localctx, 1);
				{
				State = 246; codop3();
				State = 247; Match(T__16);
				State = 248; Match(NUM);
				}
				break;

			case 2:
                        x = _input.Lt(1).Text;
                        y = _input.Lt(3).Text;
                        int ln = cs[numeroSecuencia].probando.Count;
                        EnterOuterAlt(_localctx, 2);
				{
				State = 250; codop3();
				State = 251; Match(T__16);
				State = 252; Match(ID);
				}
                        if (paso == 2)
                        {
                            if (format4 == 1)
                            {
                                format4 = 0;

                                string a = checaNemonico(x);
                                //string b = obtenConstante(y);
                                string b = buscaTabsim(y);
                                string c;
                                if (b == "E")
                                {
                                    c = "Error simbolo no encontrado en TABSIM";
                                }
                                else
                                {
                                    string ab = checaNemonico(x);
                                    string ba = buscaTabsim(y);
                                    c = convierteObjF4(ab, b);
                                    int verif = verificaReferencia(y);
                                    if (verif == 1)
                                    {
                                        c = c + "*SE";
                                        cs[numeroSecuencia].SimbolosWord.Add(y);
                                    }
                                    else
                                    {
                                        c = c + "*";

                                    }

                                }

                                cs[numeroSecuencia].probando.Add(c);
                            }
                            else
                            {
                                string d = checaNemonico(x);
                                string cod = inmediatoM(d, y, ln);
                                cs[numeroSecuencia].probando.Add(cod);

                            }
                        }
                        break;

			case 3:
                        //Tipotabsim.Add("R");
                        x = _input.Lt(1).Text;
                        y = _input.Lt(3).Text;
                        int ln1 = _input.Lt(1).Line;
                        EnterOuterAlt(_localctx, 3);
				{
				State = 254; codop3();
				State = 255; Match(T__16);
				State = 256; expresion();
				}
                        if (paso == 2)
                        {
                            if (format4 == 1)
                            {
                                format4 = 0;

                                string a = checaNemonico(x);
                                //string b = obtenConstante(y);
                                string b = buscaTabsim(y);
                                string c;

                                string ab = checaNemonico(x);
                                string ba = buscaTabsim(y);
                                int tiporef = verificaReferencia(y);
                                c = convierteObjF4(ab, valorEtiqueta.ToString("X"));
                                if (tiporef == 1)
                                {
                                    c = c + "*SE";
                                    cs[numeroSecuencia].SimbolosWord.Add(y);
                                }
                                else
                                {
                                    c = c + "*";
                                }
                                


                                cs[numeroSecuencia].probando.Add(c);
                            }
                            else
                            {
                                string d = checaNemonico(x);
                                string e = _input.Lt(3).Text;
                                string cod = inmediatoM(d, e, ln1);
                                cs[numeroSecuencia].probando.Add(cod);

                            }
                        }
                        format4 = 0;
                        break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
                erroresProg(re);
            }
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Subf2aContext : ParserRuleContext {
		public Codop2Context codop2() {
			return GetRuleContext<Codop2Context>(0);
		}
		public RegContext[] reg() {
			return GetRuleContexts<RegContext>();
		}
		public RegContext reg(int i) {
			return GetRuleContext<RegContext>(i);
		}
		public Subf2aContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_subf2a; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGrammarSICXEVisitor<TResult> typedVisitor = visitor as IGrammarSICXEVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSubf2a(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Subf2aContext subf2a() {
		Subf2aContext _localctx = new Subf2aContext(_ctx, State);
		EnterRule(_localctx, 48, RULE_subf2a);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 260; codop2();
			State = 261; reg();
			State = 262; Match(T__8);
			State = 263; reg();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
                erroresProg(re);
            }
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Subf2bContext : ParserRuleContext {
		public RegContext reg() {
			return GetRuleContext<RegContext>(0);
		}
		public ITerminalNode NUM() { return GetToken(GrammarSICXEParser.NUM, 0); }
		public Subf2bContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_subf2b; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGrammarSICXEVisitor<TResult> typedVisitor = visitor as IGrammarSICXEVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSubf2b(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Subf2bContext subf2b() {
		Subf2bContext _localctx = new Subf2bContext(_ctx, State);
		EnterRule(_localctx, 50, RULE_subf2b);
		try {
			State = 275;
			_errHandler.Sync(this);
			switch (_input.La(1)) {
			case T__17:
				EnterOuterAlt(_localctx, 1);
				{
				State = 265; Match(T__17);
				State = 266; reg();
				State = 267; Match(T__8);
				State = 268; Match(NUM);
				}
				break;
			case T__18:
				EnterOuterAlt(_localctx, 2);
				{
				State = 270; Match(T__18);
				State = 271; reg();
				State = 272; Match(T__8);
				State = 273; Match(NUM);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
                erroresProg(re);
            }
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Subf2cContext : ParserRuleContext {
		public RegContext reg() {
			return GetRuleContext<RegContext>(0);
		}
		public Subf2cContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_subf2c; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGrammarSICXEVisitor<TResult> typedVisitor = visitor as IGrammarSICXEVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSubf2c(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Subf2cContext subf2c() {
		Subf2cContext _localctx = new Subf2cContext(_ctx, State);
		EnterRule(_localctx, 52, RULE_subf2c);
		try {
			State = 281;
			_errHandler.Sync(this);
			switch (_input.La(1)) {
			case T__19:
				EnterOuterAlt(_localctx, 1);
				{
				State = 277; Match(T__19);
				State = 278; reg();
				}
				break;
			case T__20:
				EnterOuterAlt(_localctx, 2);
				{
				State = 279; Match(T__20);
				State = 280; reg();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
                erroresProg(re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Subf2dContext : ParserRuleContext {
		public ITerminalNode NUM() { return GetToken(GrammarSICXEParser.NUM, 0); }
		public Subf2dContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_subf2d; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGrammarSICXEVisitor<TResult> typedVisitor = visitor as IGrammarSICXEVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSubf2d(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Subf2dContext subf2d() {
		Subf2dContext _localctx = new Subf2dContext(_ctx, State);
		EnterRule(_localctx, 54, RULE_subf2d);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 283; Match(T__21);
			State = 284; Match(NUM);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
                erroresProg(re);
            }
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Codop1Context : ParserRuleContext {
		public Codop1Context(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_codop1; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGrammarSICXEVisitor<TResult> typedVisitor = visitor as IGrammarSICXEVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCodop1(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Codop1Context codop1() {
		Codop1Context _localctx = new Codop1Context(_ctx, State);
		EnterRule(_localctx, 56, RULE_codop1);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 286;
			_la = _input.La(1);
			if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << T__22) | (1L << T__23) | (1L << T__24) | (1L << T__25) | (1L << T__26) | (1L << T__27))) != 0)) ) {
			_errHandler.RecoverInline(this);
			} else {
				if (_input.La(1) == TokenConstants.Eof) {
					matchedEOF = true;
				}

				_errHandler.ReportMatch(this);
				Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
                erroresProg(re);
            }
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Codop2Context : ParserRuleContext {
		public Codop2Context(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_codop2; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGrammarSICXEVisitor<TResult> typedVisitor = visitor as IGrammarSICXEVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCodop2(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Codop2Context codop2() {
		Codop2Context _localctx = new Codop2Context(_ctx, State);
		EnterRule(_localctx, 58, RULE_codop2);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 288;
			_la = _input.La(1);
			if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << T__28) | (1L << T__29) | (1L << T__30) | (1L << T__31) | (1L << T__32) | (1L << T__33))) != 0)) ) {
			_errHandler.RecoverInline(this);
			} else {
				if (_input.La(1) == TokenConstants.Eof) {
					matchedEOF = true;
				}

				_errHandler.ReportMatch(this);
				Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
                erroresProg(re);
            }
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Codop3Context : ParserRuleContext {
		public Codop3Context(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_codop3; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGrammarSICXEVisitor<TResult> typedVisitor = visitor as IGrammarSICXEVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCodop3(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Codop3Context codop3() {
		Codop3Context _localctx = new Codop3Context(_ctx, State);
		EnterRule(_localctx, 60, RULE_codop3);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 290;
			_la = _input.La(1);
			if ( !(((((_la - 35)) & ~0x3f) == 0 && ((1L << (_la - 35)) & ((1L << (T__34 - 35)) | (1L << (T__35 - 35)) | (1L << (T__36 - 35)) | (1L << (T__37 - 35)) | (1L << (T__38 - 35)) | (1L << (T__39 - 35)) | (1L << (T__40 - 35)) | (1L << (T__41 - 35)) | (1L << (T__42 - 35)) | (1L << (T__43 - 35)) | (1L << (T__44 - 35)) | (1L << (T__45 - 35)) | (1L << (T__46 - 35)) | (1L << (T__47 - 35)) | (1L << (T__48 - 35)) | (1L << (T__49 - 35)) | (1L << (T__50 - 35)) | (1L << (T__51 - 35)) | (1L << (T__52 - 35)) | (1L << (T__53 - 35)) | (1L << (T__54 - 35)) | (1L << (T__55 - 35)) | (1L << (T__56 - 35)) | (1L << (T__57 - 35)) | (1L << (T__58 - 35)) | (1L << (T__59 - 35)) | (1L << (T__60 - 35)) | (1L << (T__61 - 35)) | (1L << (T__62 - 35)) | (1L << (T__63 - 35)) | (1L << (T__64 - 35)) | (1L << (T__65 - 35)) | (1L << (T__66 - 35)) | (1L << (T__67 - 35)) | (1L << (T__68 - 35)) | (1L << (T__69 - 35)) | (1L << (T__70 - 35)) | (1L << (T__71 - 35)) | (1L << (T__72 - 35)) | (1L << (T__73 - 35)) | (1L << (T__74 - 35)))) != 0)) ) {
			_errHandler.RecoverInline(this);
			} else {
				if (_input.La(1) == TokenConstants.Eof) {
					matchedEOF = true;
				}

				_errHandler.ReportMatch(this);
				Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
                erroresProg(re);
            }
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RegContext : ParserRuleContext {
		public RegContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_reg; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGrammarSICXEVisitor<TResult> typedVisitor = visitor as IGrammarSICXEVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitReg(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public RegContext reg() {
		RegContext _localctx = new RegContext(_ctx, State);
		EnterRule(_localctx, 62, RULE_reg);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 292;
			_la = _input.La(1);
			if ( !(_la==T__14 || ((((_la - 76)) & ~0x3f) == 0 && ((1L << (_la - 76)) & ((1L << (T__75 - 76)) | (1L << (T__76 - 76)) | (1L << (T__77 - 76)) | (1L << (T__78 - 76)) | (1L << (T__79 - 76)) | (1L << (T__80 - 76)))) != 0)) ) {
			_errHandler.RecoverInline(this);
			} else {
				if (_input.La(1) == TokenConstants.Eof) {
					matchedEOF = true;
				}

				_errHandler.ReportMatch(this);
				Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
                erroresProg(re);
            }
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExpresionContext : ParserRuleContext {
		public MultiplicacionContext[] multiplicacion() {
			return GetRuleContexts<MultiplicacionContext>();
		}
		public MultiplicacionContext multiplicacion(int i) {
			return GetRuleContext<MultiplicacionContext>(i);
		}
		public ITerminalNode[] MAS() { return GetTokens(GrammarSICXEParser.MAS); }
		public ITerminalNode MAS(int i) {
			return GetToken(GrammarSICXEParser.MAS, i);
		}
		public ITerminalNode[] MENOS() { return GetTokens(GrammarSICXEParser.MENOS); }
		public ITerminalNode MENOS(int i) {
			return GetToken(GrammarSICXEParser.MENOS, i);
		}
		public ExpresionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_expresion; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGrammarSICXEVisitor<TResult> typedVisitor = visitor as IGrammarSICXEVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpresion(this);
			else return visitor.VisitChildren(this);
		}
	}

    public string completa6(string s)
        {
            string sl = "";
            switch (s.Length)
            {
                case 1:
                    sl = "00000" + s;
                    break;
                case 2:
                    sl = "0000" + s;
                    break;
                case 3:
                    sl = "000" + s;
                    break;
                case 4:
                    sl = "00" + s;
                    break;
                case 5:
                    sl = "" + s;
                    break;
            }
            return sl;
        }
	[RuleVersion(0)]
	public ExpresionContext expresion() {
          
            ExpresionContext _localctx = new ExpresionContext(_ctx, State);
		EnterRule(_localctx, 64, RULE_expresion);
           
            if (expresionlarga == 0)
            {
                cs[numeroSecuencia].verificaExpresion = buscaTipo(_input.Lt(1).Text);
                resultadoexpresion += cs[numeroSecuencia].verificaExpresion;
                string xm = "";
                xm = buscaTabsim(_input.Lt(1).Text);
                cs[numeroSecuencia].valorEtiqueta = Convert.ToInt32(xm, 16);
                pb1.Add("primer valor"+ _input.Lt(1).Text+" "+ buscaTipo(_input.Lt(1).Text));
             
                if (esWord == 1)
                {
                    if (buscaRef(_input.Lt(1).Text) == -1)
                    {
                        string dat = completa6(cs[numeroSecuencia].conthex[cs[numeroSecuencia].probando.Count - 1]);
                        cs[numeroSecuencia].SimbolosWord.Add("M"+dat + "06+" +completaEtiqueta(_input.Lt(1).Text));

                    }
                    if (cs[numeroSecuencia].verificaExpresion == 1 && buscaRef(_input.Lt(1).Text) == 0)
                    {
                        string dat = completa6(cs[numeroSecuencia].conthex[cs[numeroSecuencia].probando.Count - 1]);
                        cs[numeroSecuencia].SimbolosWord.Add("M"+dat + "06+" +completaEtiqueta(cs[4].nombreSeccion));
                    }
                }

            }

           
            pb1.Add(_input.Lt(1).Text + "<->" + valorEtiqueta);
            int xr = 0;
            pb1.Add("valor :" + _input.Lt(1).Text + " -- " + verificaExpresion.ToString());
            int _la;
            try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 294; multiplicacion();
			State = 301;
			_errHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(_input,19,_ctx);
                    _la = _input.La(1);
                    while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
                        expresionlarga = 1;
                     
                        if (_la == MAS)
                        {
                            cs[numeroSecuencia].verificaExpresion = cs[numeroSecuencia].verificaExpresion + buscaTipo(_input.Lt(2).Text);
                            resultadoexpresion = resultadoexpresion + cs[numeroSecuencia].verificaExpresion + _input.Lt(2).Text + buscaTipo(_input.Lt(2).Text);
                            pb1.Add("mas st" + _input.Lt(2).Text);
                            pb1.Add("valor :" + _input.Lt(2).Text + " -- " + cs[numeroSecuencia].verificaExpresion.ToString());
                            cs[numeroSecuencia].valorEtiqueta = cs[numeroSecuencia].valorEtiqueta + Convert.ToInt32(buscaTabsim(_input.Lt(2).Text), 16);
                            pb1.Add("dirtabsimb" + cs[numeroSecuencia].valorEtiqueta);
                            pb1.Add("mas" + cs[numeroSecuencia].valorEtiqueta.ToString("X"));
                            if (esWord == 1)
                            {
                                if (buscaRef(_input.Lt(2).Text) == -1)
                                {
                                    string dat = completa6(cs[numeroSecuencia].conthex[cs[numeroSecuencia].probando.Count - 1]);
                                    cs[numeroSecuencia].SimbolosWord.Add("M"+dat+ "06+" +completaEtiqueta(_input.Lt(2).Text));
                                }
                                if (cs[numeroSecuencia].verificaExpresion == 1 &&buscaRef(_input.Lt(2).Text) == 0)
                                {
                                    string dat = completa6(cs[numeroSecuencia].conthex[cs[numeroSecuencia].probando.Count - 1]);
                                    cs[numeroSecuencia].SimbolosWord.Add("M"+dat + "06+" +completaEtiqueta(cs[4].nombreSeccion));
                                }
                            }

                            //                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      xm= xm.ToString('X')+
                        }
                        if (_la == MENOS)
                        {
                            pb1.Add("menos st" + _input.Lt(2).Text);
                            pb1.Add("valor :" + _input.Lt(2).Text + " -- " + cs[numeroSecuencia].verificaExpresion.ToString());
                            cs[numeroSecuencia].verificaExpresion = cs[numeroSecuencia].verificaExpresion - buscaTipo(_input.Lt(2).Text);
                            resultadoexpresion = resultadoexpresion + cs[numeroSecuencia].verificaExpresion;
                            pb1.Add("verifica expresion resta" + verificaExpresion);
                            cs[numeroSecuencia].valorEtiqueta = cs[numeroSecuencia].valorEtiqueta - Convert.ToInt32(buscaTabsim(_input.Lt(2).Text), 16);
                            pb1.Add("menos" + cs[numeroSecuencia].valorEtiqueta.ToString("X"));
                        }
                        pb1.Add(cs[numeroSecuencia].verificaExpresion.ToString());
                        if ( _alt==1 ) {
					{
					State = 299;
					_errHandler.Sync(this);
					switch (_input.La(1)) {
					case MAS:
						{
                        State = 295; Match(MAS);
						State = 296; multiplicacion();
						}
						break;
					case MENOS:
						{
                          State = 297; Match(MENOS);
						State = 298; multiplicacion();
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					} 
				}
				State = 303;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,19,_ctx);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
                erroresProg(re);
            }
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MultiplicacionContext : ParserRuleContext {
		public NumeroContext[] numero() {
			return GetRuleContexts<NumeroContext>();
		}
		public NumeroContext numero(int i) {
			return GetRuleContext<NumeroContext>(i);
		}
		public ITerminalNode[] ID() { return GetTokens(GrammarSICXEParser.ID); }
		public ITerminalNode ID(int i) {
			return GetToken(GrammarSICXEParser.ID, i);
		}
		public ITerminalNode[] ENTRE() { return GetTokens(GrammarSICXEParser.ENTRE); }
		public ITerminalNode ENTRE(int i) {
			return GetToken(GrammarSICXEParser.ENTRE, i);
		}
		public ITerminalNode[] POR() { return GetTokens(GrammarSICXEParser.POR); }
		public ITerminalNode POR(int i) {
			return GetToken(GrammarSICXEParser.POR, i);
		}
		public MultiplicacionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_multiplicacion; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGrammarSICXEVisitor<TResult> typedVisitor = visitor as IGrammarSICXEVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMultiplicacion(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public MultiplicacionContext multiplicacion() {
		MultiplicacionContext _localctx = new MultiplicacionContext(_ctx, State);
		EnterRule(_localctx, 66, RULE_multiplicacion);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 306;
			_errHandler.Sync(this);
			switch (_input.La(1)) {
			case PARENI:
			case INT:
				{
				State = 304; numero();
				}
				break;
			case ID:
				{
				State = 305; Match(ID);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 320;
			_errHandler.Sync(this);
			_la = _input.La(1);
			while (_la==POR || _la==ENTRE) {
				{
				State = 318;
				_errHandler.Sync(this);
				switch (_input.La(1)) {
				case POR:
					{
					{
					State = 308; Match(POR);
					State = 311;
					_errHandler.Sync(this);
					switch (_input.La(1)) {
					case PARENI:
					case INT:
						{
						State = 309; numero();
						}
						break;
					case ID:
						{
						State = 310; Match(ID);
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					}
					}
					break;
				case ENTRE:
					{
					State = 313; Match(ENTRE);
					State = 316;
					_errHandler.Sync(this);
					switch (_input.La(1)) {
					case PARENI:
					case INT:
						{
						State = 314; numero();
						}
						break;
					case ID:
						{
						State = 315; Match(ID);
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				State = 322;
				_errHandler.Sync(this);
				_la = _input.La(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
                erroresProg(re);
            }
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class NumeroContext : ParserRuleContext {
		public ITerminalNode INT() { return GetToken(GrammarSICXEParser.INT, 0); }
		public ITerminalNode PARENI() { return GetToken(GrammarSICXEParser.PARENI, 0); }
		public ExpresionContext expresion() {
			return GetRuleContext<ExpresionContext>(0);
		}
		public ITerminalNode PAREND() { return GetToken(GrammarSICXEParser.PAREND, 0); }
		public NumeroContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_numero; } }
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			IGrammarSICXEVisitor<TResult> typedVisitor = visitor as IGrammarSICXEVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNumero(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public NumeroContext numero() {
		NumeroContext _localctx = new NumeroContext(_ctx, State);
		EnterRule(_localctx, 68, RULE_numero);
		try {
			State = 328;
			_errHandler.Sync(this);
			switch (_input.La(1)) {
			case INT:
				EnterOuterAlt(_localctx, 1);
				{
				State = 323; Match(INT);
				}
				break;
			case PARENI:
				EnterOuterAlt(_localctx, 2);
				{
				State = 324; Match(PARENI);
				State = 325; expresion();
				State = 326; Match(PAREND);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
                erroresProg(re);
            }
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public static readonly string _serializedATN =
		"\x3\xAF6F\x8320\x479D\xB75C\x4880\x1605\x191C\xAB37\x3`\x14D\x4\x2\t\x2"+
		"\x4\x3\t\x3\x4\x4\t\x4\x4\x5\t\x5\x4\x6\t\x6\x4\a\t\a\x4\b\t\b\x4\t\t"+
		"\t\x4\n\t\n\x4\v\t\v\x4\f\t\f\x4\r\t\r\x4\xE\t\xE\x4\xF\t\xF\x4\x10\t"+
		"\x10\x4\x11\t\x11\x4\x12\t\x12\x4\x13\t\x13\x4\x14\t\x14\x4\x15\t\x15"+
		"\x4\x16\t\x16\x4\x17\t\x17\x4\x18\t\x18\x4\x19\t\x19\x4\x1A\t\x1A\x4\x1B"+
		"\t\x1B\x4\x1C\t\x1C\x4\x1D\t\x1D\x4\x1E\t\x1E\x4\x1F\t\x1F\x4 \t \x4!"+
		"\t!\x4\"\t\"\x4#\t#\x4$\t$\x3\x2\x3\x2\x3\x2\x3\x2\x3\x2\x3\x3\x3\x3\x3"+
		"\x3\x3\x3\x3\x3\x3\x3\x3\x3\x3\x3\x5\x3V\n\x3\x3\x4\x3\x4\x5\x4Z\n\x4"+
		"\x3\x5\x3\x5\x3\x5\x3\x5\x3\x5\x3\x5\x5\x5\x62\n\x5\x3\x6\x3\x6\x5\x6"+
		"\x66\n\x6\x3\a\x3\a\x3\a\x3\b\x3\b\x3\b\x3\b\x5\bo\n\b\x3\t\x3\t\x5\t"+
		"s\n\t\x3\n\x3\n\x3\n\x3\n\x3\v\x3\v\x3\v\x3\v\x3\v\x3\v\x3\v\x3\v\x3\v"+
		"\x3\v\x3\v\x3\v\x3\v\x3\v\x3\v\x3\v\x3\v\x3\v\x3\v\x3\v\x3\v\x3\v\x3\v"+
		"\x3\v\x3\v\x3\v\x3\v\x3\v\x3\v\x3\v\x3\v\x3\v\x3\v\x3\v\x3\v\x3\v\x3\v"+
		"\x3\v\x3\v\x3\v\x5\v\xA1\n\v\x3\f\x3\f\x3\f\x3\f\a\f\xA7\n\f\f\f\xE\f"+
		"\xAA\v\f\x3\r\x3\r\x3\r\x3\r\a\r\xB0\n\r\f\r\xE\r\xB3\v\r\x3\xE\x3\xE"+
		"\x3\xF\x3\xF\x3\xF\x3\x10\x3\x10\x3\x11\x3\x11\x5\x11\xBE\n\x11\x3\x12"+
		"\x3\x12\x3\x12\x3\x12\x5\x12\xC4\n\x12\x3\x13\x3\x13\x3\x14\x3\x14\x3"+
		"\x14\x3\x14\x5\x14\xCC\n\x14\x3\x15\x3\x15\x3\x15\x5\x15\xD1\n\x15\x3"+
		"\x16\x3\x16\x3\x16\x3\x17\x3\x17\x3\x17\x3\x17\x3\x17\x3\x17\x3\x17\x3"+
		"\x17\x3\x17\x3\x17\x3\x17\x3\x17\x3\x17\x3\x17\x3\x17\x3\x17\x3\x17\x3"+
		"\x17\x3\x17\x5\x17\xE9\n\x17\x3\x18\x3\x18\x3\x18\x3\x18\x3\x18\x3\x18"+
		"\x3\x18\x3\x18\x3\x18\x3\x18\x3\x18\x3\x18\x5\x18\xF7\n\x18\x3\x19\x3"+
		"\x19\x3\x19\x3\x19\x3\x19\x3\x19\x3\x19\x3\x19\x3\x19\x3\x19\x3\x19\x3"+
		"\x19\x5\x19\x105\n\x19\x3\x1A\x3\x1A\x3\x1A\x3\x1A\x3\x1A\x3\x1B\x3\x1B"+
		"\x3\x1B\x3\x1B\x3\x1B\x3\x1B\x3\x1B\x3\x1B\x3\x1B\x3\x1B\x5\x1B\x116\n"+
		"\x1B\x3\x1C\x3\x1C\x3\x1C\x3\x1C\x5\x1C\x11C\n\x1C\x3\x1D\x3\x1D\x3\x1D"+
		"\x3\x1E\x3\x1E\x3\x1F\x3\x1F\x3 \x3 \x3!\x3!\x3\"\x3\"\x3\"\x3\"\x3\""+
		"\a\"\x12E\n\"\f\"\xE\"\x131\v\"\x3#\x3#\x5#\x135\n#\x3#\x3#\x3#\x5#\x13A"+
		"\n#\x3#\x3#\x3#\x5#\x13F\n#\a#\x141\n#\f#\xE#\x144\v#\x3$\x3$\x3$\x3$"+
		"\x3$\x5$\x14B\n$\x3$\x2\x2\x2%\x2\x2\x4\x2\x6\x2\b\x2\n\x2\f\x2\xE\x2"+
		"\x10\x2\x12\x2\x14\x2\x16\x2\x18\x2\x1A\x2\x1C\x2\x1E\x2 \x2\"\x2$\x2"+
		"&\x2(\x2*\x2,\x2.\x2\x30\x2\x32\x2\x34\x2\x36\x2\x38\x2:\x2<\x2>\x2@\x2"+
		"\x42\x2\x44\x2\x46\x2\x2\b\x3\x2\r\xF\x3\x2UV\x3\x2\x19\x1E\x3\x2\x1F"+
		"$\x3\x2%M\x4\x2\x11\x11NS\x156\x2H\x3\x2\x2\x2\x4U\x3\x2\x2\x2\x6Y\x3"+
		"\x2\x2\x2\b\x61\x3\x2\x2\x2\n\x65\x3\x2\x2\x2\fg\x3\x2\x2\x2\xEn\x3\x2"+
		"\x2\x2\x10r\x3\x2\x2\x2\x12t\x3\x2\x2\x2\x14\xA0\x3\x2\x2\x2\x16\xA2\x3"+
		"\x2\x2\x2\x18\xAB\x3\x2\x2\x2\x1A\xB4\x3\x2\x2\x2\x1C\xB6\x3\x2\x2\x2"+
		"\x1E\xB9\x3\x2\x2\x2 \xBD\x3\x2\x2\x2\"\xC3\x3\x2\x2\x2$\xC5\x3\x2\x2"+
		"\x2&\xCB\x3\x2\x2\x2(\xD0\x3\x2\x2\x2*\xD2\x3\x2\x2\x2,\xE8\x3\x2\x2\x2"+
		".\xF6\x3\x2\x2\x2\x30\x104\x3\x2\x2\x2\x32\x106\x3\x2\x2\x2\x34\x115\x3"+
		"\x2\x2\x2\x36\x11B\x3\x2\x2\x2\x38\x11D\x3\x2\x2\x2:\x120\x3\x2\x2\x2"+
		"<\x122\x3\x2\x2\x2>\x124\x3\x2\x2\x2@\x126\x3\x2\x2\x2\x42\x128\x3\x2"+
		"\x2\x2\x44\x134\x3\x2\x2\x2\x46\x14A\x3\x2\x2\x2HI\x5\x4\x3\x2IJ\x5\f"+
		"\a\x2JK\x5\b\x5\x2KL\a\x2\x2\x3L\x3\x3\x2\x2\x2MN\x5\x6\x4\x2NO\a\x3\x2"+
		"\x2OP\aT\x2\x2PQ\aX\x2\x2QV\x3\x2\x2\x2RS\x5\x10\t\x2ST\aX\x2\x2TV\x3"+
		"\x2\x2\x2UM\x3\x2\x2\x2UR\x3\x2\x2\x2V\x5\x3\x2\x2\x2WZ\aW\x2\x2XZ\x3"+
		"\x2\x2\x2YW\x3\x2\x2\x2YX\x3\x2\x2\x2Z\a\x3\x2\x2\x2[\\\a\x4\x2\x2\\]"+
		"\x5\n\x6\x2]^\aX\x2\x2^\x62\x3\x2\x2\x2_`\a\x4\x2\x2`\x62\x5\n\x6\x2\x61"+
		"[\x3\x2\x2\x2\x61_\x3\x2\x2\x2\x62\t\x3\x2\x2\x2\x63\x66\aW\x2\x2\x64"+
		"\x66\x3\x2\x2\x2\x65\x63\x3\x2\x2\x2\x65\x64\x3\x2\x2\x2\x66\v\x3\x2\x2"+
		"\x2gh\x5\x10\t\x2hi\x5\xE\b\x2i\r\x3\x2\x2\x2jk\x5\x10\t\x2kl\x5\xE\b"+
		"\x2lo\x3\x2\x2\x2mo\x3\x2\x2\x2nj\x3\x2\x2\x2nm\x3\x2\x2\x2o\xF\x3\x2"+
		"\x2\x2ps\x5\x12\n\x2qs\x5\x14\v\x2rp\x3\x2\x2\x2rq\x3\x2\x2\x2s\x11\x3"+
		"\x2\x2\x2tu\x5\x6\x4\x2uv\x5 \x11\x2vw\aX\x2\x2w\x13\x3\x2\x2\x2xy\x5"+
		"\x6\x4\x2yz\x5\x1A\xE\x2z{\aT\x2\x2{|\aX\x2\x2|\xA1\x3\x2\x2\x2}~\x5\x6"+
		"\x4\x2~\x7F\x5\x1C\xF\x2\x7F\x80\aX\x2\x2\x80\xA1\x3\x2\x2\x2\x81\x82"+
		"\x5\x6\x4\x2\x82\x83\a\x5\x2\x2\x83\x84\x5\x1E\x10\x2\x84\x85\aX\x2\x2"+
		"\x85\xA1\x3\x2\x2\x2\x86\x87\x5\x6\x4\x2\x87\x88\a\x6\x2\x2\x88\x89\x5"+
		"\x42\"\x2\x89\xA1\x3\x2\x2\x2\x8A\x8B\x5\x6\x4\x2\x8B\x8C\a\a\x2\x2\x8C"+
		"\x8D\aX\x2\x2\x8D\xA1\x3\x2\x2\x2\x8E\x8F\x5\x6\x4\x2\x8F\x90\a\x6\x2"+
		"\x2\x90\x91\aT\x2\x2\x91\x92\aX\x2\x2\x92\xA1\x3\x2\x2\x2\x93\x94\a\b"+
		"\x2\x2\x94\x95\x5\x6\x4\x2\x95\x96\aX\x2\x2\x96\xA1\x3\x2\x2\x2\x97\x98"+
		"\aW\x2\x2\x98\x99\a\t\x2\x2\x99\xA1\aX\x2\x2\x9A\x9B\x5\x6\x4\x2\x9B\x9C"+
		"\x5\x1A\xE\x2\x9C\x9D\x5\x42\"\x2\x9D\xA1\x3\x2\x2\x2\x9E\xA1\x5\x16\f"+
		"\x2\x9F\xA1\x5\x18\r\x2\xA0x\x3\x2\x2\x2\xA0}\x3\x2\x2\x2\xA0\x81\x3\x2"+
		"\x2\x2\xA0\x86\x3\x2\x2\x2\xA0\x8A\x3\x2\x2\x2\xA0\x8E\x3\x2\x2\x2\xA0"+
		"\x93\x3\x2\x2\x2\xA0\x97\x3\x2\x2\x2\xA0\x9A\x3\x2\x2\x2\xA0\x9E\x3\x2"+
		"\x2\x2\xA0\x9F\x3\x2\x2\x2\xA1\x15\x3\x2\x2\x2\xA2\xA3\a\n\x2\x2\xA3\xA8"+
		"\x5\x6\x4\x2\xA4\xA5\a\v\x2\x2\xA5\xA7\x5\x6\x4\x2\xA6\xA4\x3\x2\x2\x2"+
		"\xA7\xAA\x3\x2\x2\x2\xA8\xA6\x3\x2\x2\x2\xA8\xA9\x3\x2\x2\x2\xA9\x17\x3"+
		"\x2\x2\x2\xAA\xA8\x3\x2\x2\x2\xAB\xAC\a\f\x2\x2\xAC\xB1\x5\x6\x4\x2\xAD"+
		"\xAE\a\v\x2\x2\xAE\xB0\x5\x6\x4\x2\xAF\xAD\x3\x2\x2\x2\xB0\xB3\x3\x2\x2"+
		"\x2\xB1\xAF\x3\x2\x2\x2\xB1\xB2\x3\x2\x2\x2\xB2\x19\x3\x2\x2\x2\xB3\xB1"+
		"\x3\x2\x2\x2\xB4\xB5\t\x2\x2\x2\xB5\x1B\x3\x2\x2\x2\xB6\xB7\a\x10\x2\x2"+
		"\xB7\xB8\aW\x2\x2\xB8\x1D\x3\x2\x2\x2\xB9\xBA\t\x3\x2\x2\xBA\x1F\x3\x2"+
		"\x2\x2\xBB\xBE\x5\"\x12\x2\xBC\xBE\x3\x2\x2\x2\xBD\xBB\x3\x2\x2\x2\xBD"+
		"\xBC\x3\x2\x2\x2\xBE!\x3\x2\x2\x2\xBF\xC4\x5$\x13\x2\xC0\xC4\x5&\x14\x2"+
		"\xC1\xC4\x5(\x15\x2\xC2\xC4\x5*\x16\x2\xC3\xBF\x3\x2\x2\x2\xC3\xC0\x3"+
		"\x2\x2\x2\xC3\xC1\x3\x2\x2\x2\xC3\xC2\x3\x2\x2\x2\xC4#\x3\x2\x2\x2\xC5"+
		"\xC6\x5:\x1E\x2\xC6%\x3\x2\x2\x2\xC7\xCC\x5\x32\x1A\x2\xC8\xCC\x5\x34"+
		"\x1B\x2\xC9\xCC\x5\x36\x1C\x2\xCA\xCC\x5\x38\x1D\x2\xCB\xC7\x3\x2\x2\x2"+
		"\xCB\xC8\x3\x2\x2\x2\xCB\xC9\x3\x2\x2\x2\xCB\xCA\x3\x2\x2\x2\xCC\'\x3"+
		"\x2\x2\x2\xCD\xD1\x5,\x17\x2\xCE\xD1\x5.\x18\x2\xCF\xD1\x5\x30\x19\x2"+
		"\xD0\xCD\x3\x2\x2\x2\xD0\xCE\x3\x2\x2\x2\xD0\xCF\x3\x2\x2\x2\xD1)\x3\x2"+
		"\x2\x2\xD2\xD3\a[\x2\x2\xD3\xD4\x5(\x15\x2\xD4+\x3\x2\x2\x2\xD5\xD6\x5"+
		"> \x2\xD6\xD7\aW\x2\x2\xD7\xE9\x3\x2\x2\x2\xD8\xD9\x5> \x2\xD9\xDA\aT"+
		"\x2\x2\xDA\xE9\x3\x2\x2\x2\xDB\xDC\x5> \x2\xDC\xDD\aT\x2\x2\xDD\xDE\a"+
		"\v\x2\x2\xDE\xDF\a\x11\x2\x2\xDF\xE9\x3\x2\x2\x2\xE0\xE1\x5> \x2\xE1\xE2"+
		"\aW\x2\x2\xE2\xE3\a\v\x2\x2\xE3\xE4\a\x11\x2\x2\xE4\xE9\x3\x2\x2\x2\xE5"+
		"\xE6\x5> \x2\xE6\xE7\x5\x42\"\x2\xE7\xE9\x3\x2\x2\x2\xE8\xD5\x3\x2\x2"+
		"\x2\xE8\xD8\x3\x2\x2\x2\xE8\xDB\x3\x2\x2\x2\xE8\xE0\x3\x2\x2\x2\xE8\xE5"+
		"\x3\x2\x2\x2\xE9-\x3\x2\x2\x2\xEA\xEB\x5> \x2\xEB\xEC\a\x12\x2\x2\xEC"+
		"\xED\aT\x2\x2\xED\xF7\x3\x2\x2\x2\xEE\xEF\x5> \x2\xEF\xF0\a\x12\x2\x2"+
		"\xF0\xF1\aW\x2\x2\xF1\xF7\x3\x2\x2\x2\xF2\xF3\x5> \x2\xF3\xF4\a\x12\x2"+
		"\x2\xF4\xF5\x5\x42\"\x2\xF5\xF7\x3\x2\x2\x2\xF6\xEA\x3\x2\x2\x2\xF6\xEE"+
		"\x3\x2\x2\x2\xF6\xF2\x3\x2\x2\x2\xF7/\x3\x2\x2\x2\xF8\xF9\x5> \x2\xF9"+
		"\xFA\a\x13\x2\x2\xFA\xFB\aT\x2\x2\xFB\x105\x3\x2\x2\x2\xFC\xFD\x5> \x2"+
		"\xFD\xFE\a\x13\x2\x2\xFE\xFF\aW\x2\x2\xFF\x105\x3\x2\x2\x2\x100\x101\x5"+
		"> \x2\x101\x102\a\x13\x2\x2\x102\x103\x5\x42\"\x2\x103\x105\x3\x2\x2\x2"+
		"\x104\xF8\x3\x2\x2\x2\x104\xFC\x3\x2\x2\x2\x104\x100\x3\x2\x2\x2\x105"+
		"\x31\x3\x2\x2\x2\x106\x107\x5<\x1F\x2\x107\x108\x5@!\x2\x108\x109\a\v"+
		"\x2\x2\x109\x10A\x5@!\x2\x10A\x33\x3\x2\x2\x2\x10B\x10C\a\x14\x2\x2\x10C"+
		"\x10D\x5@!\x2\x10D\x10E\a\v\x2\x2\x10E\x10F\aT\x2\x2\x10F\x116\x3\x2\x2"+
		"\x2\x110\x111\a\x15\x2\x2\x111\x112\x5@!\x2\x112\x113\a\v\x2\x2\x113\x114"+
		"\aT\x2\x2\x114\x116\x3\x2\x2\x2\x115\x10B\x3\x2\x2\x2\x115\x110\x3\x2"+
		"\x2\x2\x116\x35\x3\x2\x2\x2\x117\x118\a\x16\x2\x2\x118\x11C\x5@!\x2\x119"+
		"\x11A\a\x17\x2\x2\x11A\x11C\x5@!\x2\x11B\x117\x3\x2\x2\x2\x11B\x119\x3"+
		"\x2\x2\x2\x11C\x37\x3\x2\x2\x2\x11D\x11E\a\x18\x2\x2\x11E\x11F\aT\x2\x2"+
		"\x11F\x39\x3\x2\x2\x2\x120\x121\t\x4\x2\x2\x121;\x3\x2\x2\x2\x122\x123"+
		"\t\x5\x2\x2\x123=\x3\x2\x2\x2\x124\x125\t\x6\x2\x2\x125?\x3\x2\x2\x2\x126"+
		"\x127\t\a\x2\x2\x127\x41\x3\x2\x2\x2\x128\x12F\x5\x44#\x2\x129\x12A\a"+
		"[\x2\x2\x12A\x12E\x5\x44#\x2\x12B\x12C\a\\\x2\x2\x12C\x12E\x5\x44#\x2"+
		"\x12D\x129\x3\x2\x2\x2\x12D\x12B\x3\x2\x2\x2\x12E\x131\x3\x2\x2\x2\x12F"+
		"\x12D\x3\x2\x2\x2\x12F\x130\x3\x2\x2\x2\x130\x43\x3\x2\x2\x2\x131\x12F"+
		"\x3\x2\x2\x2\x132\x135\x5\x46$\x2\x133\x135\aW\x2\x2\x134\x132\x3\x2\x2"+
		"\x2\x134\x133\x3\x2\x2\x2\x135\x142\x3\x2\x2\x2\x136\x139\a]\x2\x2\x137"+
		"\x13A\x5\x46$\x2\x138\x13A\aW\x2\x2\x139\x137\x3\x2\x2\x2\x139\x138\x3"+
		"\x2\x2\x2\x13A\x141\x3\x2\x2\x2\x13B\x13E\a_\x2\x2\x13C\x13F\x5\x46$\x2"+
		"\x13D\x13F\aW\x2\x2\x13E\x13C\x3\x2\x2\x2\x13E\x13D\x3\x2\x2\x2\x13F\x141"+
		"\x3\x2\x2\x2\x140\x136\x3\x2\x2\x2\x140\x13B\x3\x2\x2\x2\x141\x144\x3"+
		"\x2\x2\x2\x142\x140\x3\x2\x2\x2\x142\x143\x3\x2\x2\x2\x143\x45\x3\x2\x2"+
		"\x2\x144\x142\x3\x2\x2\x2\x145\x14B\a^\x2\x2\x146\x147\aY\x2\x2\x147\x148"+
		"\x5\x42\"\x2\x148\x149\aZ\x2\x2\x149\x14B\x3\x2\x2\x2\x14A\x145\x3\x2"+
		"\x2\x2\x14A\x146\x3\x2\x2\x2\x14BG\x3\x2\x2\x2\x1CUY\x61\x65nr\xA0\xA8"+
		"\xB1\xBD\xC3\xCB\xD0\xE8\xF6\x104\x115\x11B\x12D\x12F\x134\x139\x13E\x140"+
		"\x142\x14A";
	public static readonly ATN _ATN =
		new ATNDeserializer().Deserialize(_serializedATN.ToCharArray());
}
} // namespace Example.Generated
